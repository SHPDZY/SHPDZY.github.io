<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="欢迎来到张永的个人博客，一个关注Android,H5前端,java后端技术分享，爱分享网络资源，分享学到的知识，分享生活的乐趣的网站。">
<meta property="og:type" content="website">
<meta property="og:title" content="张永的个人博客">
<meta property="og:url" content="http://shpdzy.github.io/index.html">
<meta property="og:site_name" content="张永的个人博客">
<meta property="og:description" content="欢迎来到张永的个人博客，一个关注Android,H5前端,java后端技术分享，爱分享网络资源，分享学到的知识，分享生活的乐趣的网站。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张永的个人博客">
<meta name="twitter:description" content="欢迎来到张永的个人博客，一个关注Android,H5前端,java后端技术分享，爱分享网络资源，分享学到的知识，分享生活的乐趣的网站。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://shpdzy.github.io/">





  <title>张永的个人博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张永的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/GIT常用操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/GIT常用操作/" itemprop="url">GIT常用操作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-16T16:45:41+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Git图形化界面我用的还可以，但是命令就不太会了，索性和大家一起学习下Git命令的用法…一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令</p>
<p>下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>
<pre><code>Workspace：工作区
Index / Stage：暂存区
Repository：仓库区（或本地仓库）
Remote：远程仓库</code></pre><h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><h3 id="在当前目录新建一个Git代码库"><a href="#在当前目录新建一个Git代码库" class="headerlink" title="在当前目录新建一个Git代码库"></a>在当前目录新建一个Git代码库</h3><pre><code>$ git init# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<h3 id="显示当前的Git配置"><a href="#显示当前的Git配置" class="headerlink" title="显示当前的Git配置"></a>显示当前的Git配置</h3><pre><code>$ git config --list# 编辑Git配置文件
$ git config -e [--global]# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;</code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><h3 id="添加指定文件到暂存区-git-add-file1-file2-…-添加指定目录到暂存区，包括子目录"><a href="#添加指定文件到暂存区-git-add-file1-file2-…-添加指定目录到暂存区，包括子目录" class="headerlink" title="添加指定文件到暂存区$ git add [file1] [file2] …# 添加指定目录到暂存区，包括子目录"></a>添加指定文件到暂存区$ git add [file1] [file2] …# 添加指定目录到暂存区，包括子目录</h3><pre><code>$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]</code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><h3 id="提交暂存区到仓库区-git-commit-m-message-提交暂存区的指定文件到仓库区-git-commit-file1-file2-…-m-message-提交工作区自上次commit之后的变化，直接到仓库区"><a href="#提交暂存区到仓库区-git-commit-m-message-提交暂存区的指定文件到仓库区-git-commit-file1-file2-…-m-message-提交工作区自上次commit之后的变化，直接到仓库区" class="headerlink" title="提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区"></a>提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] … -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区</h3><pre><code>$ git commit -a# 提交时显示所有diff信息
$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><h3 id="列出所有本地分支-git-branch-列出所有远程分支"><a href="#列出所有本地分支-git-branch-列出所有远程分支" class="headerlink" title="列出所有本地分支$ git branch# 列出所有远程分支"></a>列出所有本地分支$ git branch# 列出所有远程分支</h3><pre><code>$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit
$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支
$ git merge [branch]# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]</code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="列出所有tag"><a href="#列出所有tag" class="headerlink" title="列出所有tag"></a>列出所有tag</h3><pre><code>$ git tag# 新建一个tag在当前commit
$ git tag [tag]# 新建一个tag在指定commit
$ git tag [tag] [commit]# 删除本地tag
$ git tag -d [tag]# 删除远程tag
$ git push origin :refs/tags/[tagName]# 查看tag信息
$ git show [tag]# 提交指定tag
$ git push [remote] [tag]# 提交所有tag
$ git push [remote] --tags# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]</code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><h3 id="显示有变更的文件-git-status-显示当前分支的版本历史-git-log-显示commit历史，以及每次commit发生变更的文件"><a href="#显示有变更的文件-git-status-显示当前分支的版本历史-git-log-显示commit历史，以及每次commit发生变更的文件" class="headerlink" title="显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件"></a>显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件</h3><pre><code>$ git log --stat# 搜索提交历史，根据关键词
$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]# 显示指定文件相关的每一次diff
$ git log -p [file]# 显示过去5次提交
$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过
$ git blame [file]# 显示暂存区和工作区的代码差异$ git diff# 显示暂存区和上一个commit的差异
$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件
$ git show --name-only [commit]# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]# 显示当前分支的最近几次提交
$ git reflog</code></pre><h3 id="从本地master拉取代码更新当前分支：branch-一般为master"><a href="#从本地master拉取代码更新当前分支：branch-一般为master" class="headerlink" title="从本地master拉取代码更新当前分支：branch 一般为master"></a>从本地master拉取代码更新当前分支：branch 一般为master</h3><pre><code>$ git rebase [branch]</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><h3 id="下载远程仓库的所有变动"><a href="#下载远程仓库的所有变动" class="headerlink" title="下载远程仓库的所有变动"></a>下载远程仓库的所有变动</h3><pre><code>$ git fetch [remote]# 显示所有远程仓库
$ git remote -v# 显示某个远程仓库的信息
$ git remote show [remote]# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force# 推送所有分支到远程仓库
$ git push [remote] --all</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><h3 id="恢复暂存区的指定文件到工作区"><a href="#恢复暂存区的指定文件到工作区" class="headerlink" title="恢复暂存区的指定文件到工作区"></a>恢复暂存区的指定文件到工作区</h3><pre><code>$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区
$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash
$ git stash pop</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="生成一个可供发布的压缩包"><a href="#生成一个可供发布的压缩包" class="headerlink" title="生成一个可供发布的压缩包"></a>生成一个可供发布的压缩包</h3><pre><code>$ git archive</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/Handler都没搞定，拿什么去跳槽！/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/Handler都没搞定，拿什么去跳槽！/" itemprop="url">Handler都没搞定，拿什么去跳槽！</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T12:14:29+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p>
<p>Handler应用之广泛，可以说只要有异步线程与主线程通信的地方就一定会有 Handler。</p>
<p>所以搞懂 Handler 对理解Android非常有必要。</p>
<p>那么，Handler 的通信机制的背后的原理是什么？</p>
<p>本文带你揭晓。</p>
<p>注意：本文所展示的系统源码基于 Android-27 ，并有所删减。</p>
<h3 id="1-重识-Handler"><a href="#1-重识-Handler" class="headerlink" title="1. 重识 Handler"></a>1. 重识 Handler</h3><p>我们可以使用 Handler 发送并处理与一个线程关联的 Message 和 Runnable 。（注意：Runnable 会被封装进一个 Message，所以它本质上还是一个 Message ）</p>
<p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p>
<pre><code>android.os.Handler handler = new Handler(){
  @Override
  public void handleMessage(final Message msg) {
    //这里接受并处理消息
  }
};
//发送消息
handler.sendMessage(message);
handler.post(runnable);</code></pre><p>实例化一个 Handler 重写 handleMessage 方法 ，然后在需要的时候调用它的 send 以及 post 系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p>
<p>但是奇怪，我们并没有看到任何 MessageQueue 的身影，也没看到它与线程绑定的逻辑，这是怎么回事？</p>
<h3 id="2-Handler-原理解析"><a href="#2-Handler-原理解析" class="headerlink" title="2. Handler 原理解析"></a>2. Handler 原理解析</h3><p>相信大家早就听说过了 Looper 以及 MessageQueue 了，我就不多绕弯子了。</p>
<p>不过在开始分析原理之前，先明确我们的问题：</p>
<p>Handler 是如何与线程关联的？</p>
<p>Handler 发出去的消息是谁管理的？</p>
<p>消息又是怎么回到 handleMessage() 方法的？</p>
<p>线程的切换是怎么回事？</p>
<h4 id="2-1-Handler-与-Looper-的关联"><a href="#2-1-Handler-与-Looper-的关联" class="headerlink" title="2.1 Handler 与 Looper 的关联"></a>2.1 Handler 与 Looper 的关联</h4><p>实际上我们在实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 Looper 。</p>
<p>代码如下：</p>
<pre><code> public Handler(Callback callback, boolean async) {
         //检查当前的线程是否有 Looper
         mLooper = Looper.myLooper();
         if (mLooper == null) {
             throw new RuntimeException(
                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);
         }
         //Looper 持有一个 MessageQueue
         mQueue = mLooper.mQueue;
}</code></pre><p>这个异常相信很多同学遇到过，而我们平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper，先记住，后面会讲。（见【3.2】）</p>
<p>一个完整的 Handler 使用例子其实是这样的：</p>
<pre><code> class LooperThread extends Thread {
     public Handler mHandler;
     public void run() {
         Looper.prepare();
         mHandler = new Handler() {
             public void handleMessage(Message msg) {
                 // process incoming messages here
             }
         };
        Looper.loop();
    }
}</code></pre><p>Looper.prepare() :</p>
<pre><code>//Looper
private static void prepare(boolean quitAllowed) {
  if (sThreadLocal.get() != null) {
    throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);
  }
  sThreadLocal.set(new Looper(quitAllowed));
}</code></pre><p>Looper 提供了 Looper.prepare()  方法来创建 Looper ，并且会借助 ThreadLocal 来实现与当前线程的绑定功能。Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler（见【2.3】）。</p>
<p>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</p>
<h4 id="2-2-Message-的存储与管理"><a href="#2-2-Message-的存储与管理" class="headerlink" title="2.2 Message 的存储与管理"></a>2.2 Message 的存储与管理</h4><p>Handler 提供了一些列的方法让我们来发送消息，如 send()系列 post()系列 。</p>
<p>不过不管我们调用什么方法，最终都会走到 Message.enqueueMessage(Message,long) 方法。</p>
<p>以 sendEmptyMessage(int)  方法为例：</p>
<pre><code>//Handler
sendEmptyMessage(int)
  -&gt; sendEmptyMessageDelayed(int,int)
    -&gt; sendMessageAtTime(Message,long)
      -&gt; enqueueMessage(MessageQueue,Message,long)
              -&gt; queue.enqueueMessage(Message, long);</code></pre><p>到了这里，消息的管理者 MessageQueue 也就露出了水面。<br>MessageQueue 顾明思议，就是个队列，负责消息的入队出队。</p>
<h4 id="2-3-Message-的分发与处理"><a href="#2-3-Message-的分发与处理" class="headerlink" title="2.3 Message 的分发与处理"></a>2.3 Message 的分发与处理</h4><p>了解清楚 Message 的发送与存储管理后，就该揭开分发与处理的面纱了。</p>
<p>前面说到了 Looper.loop()  负责对消息的分发，本章节进行分析。</p>
<p>先来看看所涉及到的方法：</p>
<pre><code>//Looper
public static void loop() {
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);
    }
    final MessageQueue queue = me.mQueue;
    //...
    for (;;) {
       // 不断从 MessageQueue 获取 消息
        Message msg = queue.next(); // might block
        //退出 Looper 
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            return;
        }
        //...
        try {
            msg.target.dispatchMessage(msg);
            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();
        } finally {
            //...
        }
        //...
                //回收 message, 见【3.5】
        msg.recycleUnchecked();
    }
}</code></pre><p>loop() 里调用了 MessageQueue.next() :</p>
<pre><code>//MessageQueue
Message next() {
    //...
    for (;;) {
        //...
        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            //...
            if (msg != null) {
                if (now &lt; msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
        }

        // Run the idle handlers. 关于 IdleHandler 自行了解
        //...
    }
}</code></pre><p>还调用了 msg.target.dispatchMessage(msg) ，msg.target 就是发送该消息的 Handler，这样就回调到了 Handler 那边去了:</p>
<pre><code> //Handler
 public void dispatchMessage(Message msg) {
   //msg.callback 是 Runnable ，如果是 post方法则会走这个 if
   if (msg.callback != null) {
     handleCallback(msg);
   } else {
     //callback 见【3.4】
     if (mCallback != null) {
       if (mCallback.handleMessage(msg)) {
        return;
      }
    }
    //回调到 Handler 的 handleMessage 方法
    handleMessage(msg);
  }
}</code></pre><p>注意：dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 Runnable.run() 。</p>
<p>分析：Looper.loop() 是个死循环，会不断调用 MessageQueue.next() 获取 Message ，并调用 msg.target.dispatchMessage(msg) 回到了 Handler 来分发消息，以此来完成消息的回调。</p>
<p>注意：loop()方法并不会卡死主线程，见【6】。</p>
<p>那么线程的切换又是怎么回事呢？<br>很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：</p>
<pre><code>Thread.foo(){
    Looper.loop()
     -&gt; MessageQueue.next()
       -&gt; Message.target.dispatchMessage()
        -&gt; Handler.handleMessage()
}</code></pre><p>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</p>
<p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 handleMessage() 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p>
<p><img src="../Handler%E9%83%BD%E6%B2%A1%E6%90%9E%E5%AE%9A%EF%BC%8C%E6%8B%BF%E4%BB%80%E4%B9%88%E5%8E%BB%E8%B7%B3%E6%A7%BD%EF%BC%81/1.png" alt><br><img src="../Handler%E9%83%BD%E6%B2%A1%E6%90%9E%E5%AE%9A%EF%BC%8C%E6%8B%BF%E4%BB%80%E4%B9%88%E5%8E%BB%E8%B7%B3%E6%A7%BD%EF%BC%81/2.png" alt></p>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p>
<p>尝试小结一下它们的职责，如下：</p>
<ul>
<li><p>Looper ：负责关联线程以及消息的分发，会与创建它的线程绑定，并负责在该线程下从 MessageQueue 获取 Message，分发给 Handler ；</p>
</li>
<li><p>MessageQueue ：是个队列，负责消息的存储与管理，负责管理由 Handler 发送过来的 Message ；</p>
</li>
<li><p>Handler : 负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。</p>
</li>
</ul>
<p>对【2】章节提出的问题用一句话总结：</p>
<p>Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。</p>
<p>线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。</p>
<h3 id="3-Handler-的延伸"><a href="#3-Handler-的延伸" class="headerlink" title="3. Handler 的延伸"></a>3. Handler 的延伸</h3><p>Handler 虽然简单易用，但是要用好它还是需要注意一点，另外 Handler相关 还有些鲜为人知的知识技巧，比如 IdleHandler。</p>
<p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。</p>
<p>这些我会讲解一些，我没讲到的可以自行搜索相关内容进行了解。</p>
<h4 id="3-1-Handler-引起的内存泄露原因以及最佳解决方案"><a href="#3-1-Handler-引起的内存泄露原因以及最佳解决方案" class="headerlink" title="3.1 Handler 引起的内存泄露原因以及最佳解决方案"></a>3.1 Handler 引起的内存泄露原因以及最佳解决方案</h4><p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p>
<p>这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p>
<p>解决该问题的最有效的方法是：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。</p>
<p>示例代码如下：</p>
<pre><code> private static class SafeHandler extends Handler {

     private WeakReference&lt;HandlerActivity&gt; ref;

     public SafeHandler(HandlerActivity activity) {
         this.ref = new WeakReference(activity);
     }

     @Override
    public void handleMessage(final Message msg) {
        HandlerActivity activity = ref.get();
        if (activity != null) {
            activity.handleMessage(msg);
        }
    }
}</code></pre><p>并且再在 Activity.onDestroy() 前移除消息，加一层保障：</p>
<pre><code>@Override
protected void onDestroy() {
  safeHandler.removeCallbacksAndMessages(null);
  super.onDestroy();
}</code></pre><p>这样双重保障，就能完全避免内存泄露了。</p>
<p>注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。</p>
<h4 id="3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？"><a href="#3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？" class="headerlink" title="3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？"></a>3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</h4><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p>
<p>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</p>
<p>在 ActivityThread.main() 方法中有如下代码：</p>
<pre><code> //android.app.ActivityThread
 public static void main(String[] args) {
   //...
   Looper.prepareMainLooper();

   ActivityThread thread = new ActivityThread();
   thread.attach(false);

   if (sMainThreadHandler == null) {
    sMainThreadHandler = thread.getHandler();
  }
  //...
  Looper.loop();

  throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);
}</code></pre><p>Looper.prepareMainLooper(); 代码如下：</p>
<pre><code>/**
 * Initialize the current thread as a looper, marking it as an
 * application&apos;s main looper. The main looper for your application
 * is created by the Android environment, so you should never need
 * to call this function yourself.  See also: {@link #prepare()}
 */
public static void prepareMainLooper() {
    prepare(false);
    synchronized (Looper.class) {
        if (sMainLooper != null) {
            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);
        }
        sMainLooper = myLooper();
    }
}</code></pre><p>可以看到在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。</p>
<p>注意：Looper.loop() 是个死循环，后面的代码正常情况不会执行。</p>
<h4 id="3-3-主线程的-Looper-不允许退出"><a href="#3-3-主线程的-Looper-不允许退出" class="headerlink" title="3.3 主线程的 Looper 不允许退出"></a>3.3 主线程的 Looper 不允许退出</h4><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p>
<pre><code>Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.
  at android.os.MessageQueue.quit(MessageQueue.java:415)
  at android.os.Looper.quit(Looper.java:240)</code></pre><p>why? 其实原因很简单，主线程不允许退出，退出就意味 APP 要挂。</p>
<h4 id="3-4-Handler-里藏着的-Callback-能干什么？"><a href="#3-4-Handler-里藏着的-Callback-能干什么？" class="headerlink" title="3.4 Handler 里藏着的 Callback 能干什么？"></a>3.4 Handler 里藏着的 Callback 能干什么？</h4><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p>
<p>来看看 Handler.dispatchMessage(msg)  方法：</p>
<pre><code>public void dispatchMessage(Message msg) {
  //这里的 callback 是 Runnable
  if (msg.callback != null) {
    handleCallback(msg);
  } else {
    //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage
    if (mCallback != null) {
      if (mCallback.handleMessage(msg)) {
        return;
      }
    }
    handleMessage(msg);
  }
}</code></pre><p>可以看到 Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。</p>
<p>这个就很有意思了，这有什么作用呢？</p>
<p>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</p>
<p>场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p>
<h4 id="3-5-创建-Message-实例的最佳方式"><a href="#3-5-创建-Message-实例的最佳方式" class="headerlink" title="3.5 创建 Message 实例的最佳方式"></a>3.5 创建 Message 实例的最佳方式</h4><p>由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</p>
<p>方法有二：</p>
<p>通过 Message 的静态方法 Message.obtain();   获取；</p>
<p>通过 Handler 的公有方法 handler.obtainMessage(); 。</p>
<h4 id="3-6-子线程里弹-Toast-的正确姿势"><a href="#3-6-子线程里弹-Toast-的正确姿势" class="headerlink" title="3.6 子线程里弹 Toast 的正确姿势"></a>3.6 子线程里弹 Toast 的正确姿势</h4><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p>
<pre><code>java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() </code></pre><p>本质上是因为 Toast 的实现依赖于 Handler，按子线程使用 Handler 的要求修改即可（见【2.1】），同理的还有 Dialog。</p>
<p>正确示例代码如下：</p>
<pre><code>new Thread(new Runnable() {
  @Override
  public void run() {
    Looper.prepare();
    Toast.makeText(HandlerActivity.this, &quot;不会崩溃啦！&quot;, Toast.LENGTH_SHORT).show();
    Looper.loop();
  }
});</code></pre><h4 id="3-7-妙用-Looper-机制"><a href="#3-7-妙用-Looper-机制" class="headerlink" title="3.7 妙用 Looper 机制"></a>3.7 妙用 Looper 机制</h4><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p>
<p>将 Runnable post 到主线程执行；</p>
<p>利用 Looper 判断当前线程是否是主线程。</p>
<p>完整示例代码如下：</p>
<pre><code> public final class MainThread {

     private MainThread() {
     }

     private static final Handler HANDLER = new Handler(Looper.getMainLooper());

     public static void run(@NonNull Runnable runnable) {
         if (isMainThread()) {
            runnable.run();
        }else{
            HANDLER.post(runnable);
        }
    }

    public static boolean isMainThread() {
        return Looper.myLooper() == Looper.getMainLooper();
    }

}</code></pre><p>能够省去不少样板代码。</p>
<h3 id="4-知识点汇总"><a href="#4-知识点汇总" class="headerlink" title="4. 知识点汇总"></a>4. 知识点汇总</h3><p>由前文可得出一些知识点，汇总一下，方便记忆。</p>
<p>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</p>
<p>在创建 Handler 之前一定需要先创建 Looper；</p>
<p>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</p>
<p>异步线程的 Looper 需要自己调用 Looper.myLooper().quit();  退出；</p>
<p>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</p>
<p>Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</p>
<p>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>Handler 简单易用的背后藏着工程师大量的智慧，要努力向他们学习。</p>
<p>看完并理解本文可以说你对 Handler 有了一个非常深入且全面的了解，应对面试肯定是绰绰有余了。</p>
<h3 id="6-参考和推荐"><a href="#6-参考和推荐" class="headerlink" title="6. 参考和推荐"></a>6. 参考和推荐</h3><p><a href="https://developer.android.com/reference/android/os/Handler" title="Handler" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/Handler</a><br><a href="https://stackoverflow.com/questions/12877944/what-is-the-relationship-between-looper-handler-and-messagequeue-in-android" title="what-is-the-relationship-between-looper-handler-and-messagequeue-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/12877944/what-is-the-relationship-between-looper-handler-and-messagequeue-in-android</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" title="Android消息机制1-Handler（Java 层" target="_blank" rel="noopener">http://gityuan.com/2015/12/26/handler-message-framework/</a>）<br><a href="https://www.zhihu.com/question/34652589/answer/90344494" title="Android中为什么主线程不会卡死" target="_blank" rel="noopener">https://www.zhihu.com/question/34652589/answer/90344494</a></p>
<hr>
<p>本文原作者： 程序亦非猿<br>本文原链接： <a href="http://yifeiyuan.me/blog/f77487d3.html" target="_blank" rel="noopener">http://yifeiyuan.me/blog/f77487d3.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/Android大厂面试题锦集/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/Android大厂面试题锦集/" itemprop="url">Android大厂面试题锦集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-15T14:34:56+08:00">
                2019-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/面试题/" itemprop="url" rel="index">
                    <span itemprop="name">面试题</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-android事件分发机制，请详细说下整个流程"><a href="#1-android事件分发机制，请详细说下整个流程" class="headerlink" title="1.android事件分发机制，请详细说下整个流程"></a>1.android事件分发机制，请详细说下整个流程</h3><p><img src="../Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.png" alt></p>
<h3 id="2-android-view绘制机制和加载过程，请详细说下整个流程"><a href="#2-android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="2.android view绘制机制和加载过程，请详细说下整个流程"></a>2.android view绘制机制和加载过程，请详细说下整个流程</h3><ol>
<li><p>ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。</p>
</li>
<li><p>performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。</p>
</li>
<li><p>performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。</p>
</li>
<li><p>performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。</p>
</li>
<li><p>MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。</p>
</li>
<li><p>三种方式获取measure()后的宽高：</p>
<ul>
<li>Activity#onWindowFocusChange()中调用获取</li>
<li>view.post(Runnable)将获取的代码投递到消息队列的尾部。</li>
<li>ViewTreeObservable.</li>
</ul>
</li>
</ol>
<h3 id="3-android四大组件的加载过程，请详细介绍下"><a href="#3-android四大组件的加载过程，请详细介绍下" class="headerlink" title="3.android四大组件的加载过程，请详细介绍下"></a>3.android四大组件的加载过程，请详细介绍下</h3><ol>
<li><a href="https://www.jianshu.com/p/f499afd8d0ab" title="android四大组件的加载过程" target="_blank" rel="noopener">https://www.jianshu.com/p/f499afd8d0ab</a>:这是我总结的一篇博客</li>
</ol>
<h3 id="4-Activity的启动模式"><a href="#4-Activity的启动模式" class="headerlink" title="4.Activity的启动模式"></a>4.Activity的启动模式</h3><ol>
<li>standard:默认标准模式，每启动一个都会创建一个实例，</li>
<li>singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始</li>
<li>singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈</li>
<li>singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈，</li>
</ol>
<h3 id="5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的"><a href="#5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的" class="headerlink" title="5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的"></a>5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的</h3><ol>
<li>这个题目需要深入了解activity的启动模式</li>
<li>最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C</li>
</ol>
<h3 id="6-Activity缓存方法"><a href="#6-Activity缓存方法" class="headerlink" title="6.Activity缓存方法"></a>6.Activity缓存方法</h3><ol>
<li>配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。</li>
<li>内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。</li>
</ol>
<h3 id="7-Service的生命周期，两种启动方法，有什么区别"><a href="#7-Service的生命周期，两种启动方法，有什么区别" class="headerlink" title="7.Service的生命周期，两种启动方法，有什么区别"></a>7.Service的生命周期，两种启动方法，有什么区别</h3><ol>
<li><p>context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down</p>
<ul>
<li>如果Service还没有运行，则调用onCreate()然后调用onStart()；</li>
<li>如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</li>
<li>调用stopService的时候直接onDestroy，</li>
<li>如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop</p>
<ul>
<li>onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。</li>
<li>这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。</li>
<li>所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</li>
</ul>
</li>
</ol>
<h3 id="8-怎么保证service不被杀死"><a href="#8-怎么保证service不被杀死" class="headerlink" title="8.怎么保证service不被杀死"></a>8.怎么保证service不被杀死</h3><ol>
<li>提升service优先级</li>
<li>提升service进程优先级</li>
<li>onDestroy方法里重启service</li>
</ol>
<h3 id="9-静态的Broadcast-和动态的有什么区别"><a href="#9-静态的Broadcast-和动态的有什么区别" class="headerlink" title="9.静态的Broadcast 和动态的有什么区别"></a>9.静态的Broadcast 和动态的有什么区别</h3><ol>
<li>动态的比静态的安全</li>
<li>静态在app启动的时候就初始化了 动态使用代码初始化</li>
<li>静态需要配置 动态不需要</li>
<li>生存期，静态广播的生存期可以比动态广播的长很多</li>
<li>优先级动态广播的优先级比静态广播高</li>
</ol>
<h3 id="10-Intent可以传递哪些数据类型"><a href="#10-Intent可以传递哪些数据类型" class="headerlink" title="10.Intent可以传递哪些数据类型"></a>10.Intent可以传递哪些数据类型</h3><ol>
<li>Serializable</li>
<li>charsequence: 主要用来传递String，char等</li>
<li>parcelable</li>
<li>Bundle</li>
</ol>
<h3 id="11-Json有什么优劣势、解析的原理"><a href="#11-Json有什么优劣势、解析的原理" class="headerlink" title="11.Json有什么优劣势、解析的原理"></a>11.Json有什么优劣势、解析的原理</h3><ol>
<li>JSON的速度要远远快于XML</li>
<li>JSON相对于XML来讲，数据的体积小</li>
<li>JSON对数据的描述性比XML较差</li>
<li>解析的基本原理是：词法分析</li>
</ol>
<h3 id="12-一个语言的编译过程"><a href="#12-一个语言的编译过程" class="headerlink" title="12.一个语言的编译过程"></a>12.一个语言的编译过程</h3><ol>
<li>词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式</li>
<li>语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上</li>
<li>语义分析：对结构上正确的源程序进行上下文有关性质的审查</li>
<li>目标代码生成</li>
<li>代码优化：优化生成的目标代码，</li>
</ol>
<h3 id="13-动画有哪几类，各有什么特点"><a href="#13-动画有哪几类，各有什么特点" class="headerlink" title="13.动画有哪几类，各有什么特点"></a>13.动画有哪几类，各有什么特点</h3><ol>
<li><p>动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。</p>
</li>
<li><p>View动画:只是影像变化，view的实际位置还在原来的地方。</p>
</li>
<li><p>帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。</p>
</li>
<li><p>View的属性动画：</p>
<ul>
<li>插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比</li>
<li>估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类</li>
</ul>
</li>
</ol>
<h3 id="14-Handler、Looper消息队列模型，各部分的作用"><a href="#14-Handler、Looper消息队列模型，各部分的作用" class="headerlink" title="14.Handler、Looper消息队列模型，各部分的作用"></a>14.Handler、Looper消息队列模型，各部分的作用</h3><ol>
<li>MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</li>
<li>Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。</li>
<li>Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。</li>
<li>系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。</li>
<li>MessageQueue和Looper是一对一关系，Handler和Looper是多对一</li>
</ol>
<h3 id="15-怎样退出终止App"><a href="#15-怎样退出终止App" class="headerlink" title="15.怎样退出终止App"></a>15.怎样退出终止App</h3><ol>
<li>自己设置一个Activity的栈，然后一个个finish()</li>
</ol>
<h3 id="16-Android-IPC-Binder原理"><a href="#16-Android-IPC-Binder原理" class="headerlink" title="16.Android IPC:Binder原理"></a>16.Android IPC:Binder原理</h3><ol>
<li><p>在Activity和Service进行通讯的时候，用到了Binder。</p>
<ul>
<li>当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作</li>
<li>当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>系统给我们生成的Binder：</p>
<ul>
<li>Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service</li>
<li>Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。</li>
</ul>
</li>
</ol>
<pre><code>- 哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。
- 当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。
- 如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。
- IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket</code></pre><h3 id="17-描述一次跨进程通讯"><a href="#17-描述一次跨进程通讯" class="headerlink" title="17.描述一次跨进程通讯"></a>17.描述一次跨进程通讯</h3><ol>
<li>client、proxy、serviceManager、BinderDriver、impl、service</li>
<li>client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯</li>
<li>clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯</li>
<li>中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个</li>
</ol>
<h3 id="18-android重要术语解释"><a href="#18-android重要术语解释" class="headerlink" title="18.android重要术语解释"></a>18.android重要术语解释</h3><ol>
<li>ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</li>
<li>ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</li>
<li>ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li>
<li>ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li>
<li>Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li>
<li>ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li>
<li>ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li>
<li>TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li>
</ol>
<h3 id="19-理解Window和WindowManager"><a href="#19-理解Window和WindowManager" class="headerlink" title="19.理解Window和WindowManager"></a>19.理解Window和WindowManager</h3><ol>
<li>Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</li>
<li>Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</li>
<li>Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</li>
<li>WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</li>
<li>Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</li>
<li>Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</li>
</ol>
<h3 id="20-Bitmap的处理"><a href="#20-Bitmap的处理" class="headerlink" title="20.Bitmap的处理"></a>20.Bitmap的处理</h3><ol>
<li><p>当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。</p>
</li>
<li><p>BitMap的缓存：</p>
<ul>
<li>使用LruCache进行内存缓存。</li>
<li>使用DiskLruCache进行硬盘缓存。</li>
</ul>
</li>
<li><p>实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p>
<ul>
<li>同步加载只创建一个线程然后按照顺序进行图片加载</li>
<li>异步加载使用线程池，让存在的加载任务都处于不同线程</li>
<li>为了不开启过多的异步任务，只在列表静止的时候开启图片加载</li>
</ul>
</li>
</ol>
<h3 id="21-如何实现一个网络框架-参考Volley"><a href="#21-如何实现一个网络框架-参考Volley" class="headerlink" title="21.如何实现一个网络框架(参考Volley)"></a>21.如何实现一个网络框架(参考Volley)</h3><ol>
<li>缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。</li>
<li>网络请求队列，使用线程池进行请求。</li>
<li>提供各种不同类型的返回值的解析如String，Json，图片等等。</li>
</ol>
<p>###22.ClassLoader的基础知识</p>
<ol>
<li><p>双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。</p>
</li>
<li><p>可以动态加载Jar通过URLClassLoader</p>
</li>
<li><p>ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。</p>
</li>
<li><p>加载不同Jar包中的公共类：</p>
<ul>
<li>让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)</li>
<li>重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)</li>
<li>在生成包含公共Jar的Jar时候把公共Jar去掉。</li>
</ul>
</li>
</ol>
<h3 id="23-插件化框架描述：dynamicLoadApk为例子"><a href="#23-插件化框架描述：dynamicLoadApk为例子" class="headerlink" title="23.插件化框架描述：dynamicLoadApk为例子"></a>23.插件化框架描述：dynamicLoadApk为例子</h3><ol>
<li><p>可以通过DexClassLoader来对apk中的dex包进行加载访问</p>
</li>
<li><p>如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。</p>
</li>
<li><p>由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。</p>
</li>
<li><p>缺点：</p>
<ul>
<li>慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。</li>
<li>不支持Service和静态注册的Broadcast</li>
<li>不支持LaunchMode和Apk中Activity的隐式调用。</li>
</ul>
</li>
</ol>
<h3 id="24-热修复：Andfix为例子"><a href="#24-热修复：Andfix为例子" class="headerlink" title="24.热修复：Andfix为例子"></a>24.热修复：Andfix为例子</h3><ol>
<li>大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。</li>
<li>无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效</li>
</ol>
<h3 id="25-线程同步的问题，常用的线程同步"><a href="#25-线程同步的问题，常用的线程同步" class="headerlink" title="25.线程同步的问题，常用的线程同步"></a>25.线程同步的问题，常用的线程同步</h3><ol>
<li><p>sycn：保证了原子性、可见性、有序性</p>
</li>
<li><p>锁：保证了原子性、可见性、有序性</p>
<ul>
<li><p>自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。</p>
<ul>
<li>优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。</li>
<li>缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- 阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock
- 可重入锁:一个线程可多次获取该锁，Sycn、Lock
- 悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock
- 乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas
- 显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。
- 读-写锁:为了提高性能，Java提供了读</code></pre><ol start="3">
<li><p>volatile</p>
<ul>
<li>只能保证可见性，不能保证原子性</li>
<li>自增操作有三步，此时多线程写会出现问题</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>cas</p>
<ul>
<li>操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</li>
<li>解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。</li>
<li>局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题</li>
<li>局限解决:将V带上版本。</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>线程不安全到底是怎么回事：</p>
<ul>
<li>一个线程写，多个线程读的时候，会造成写了一半就去读</li>
<li>多线程写，会造成脏数据</li>
</ul>
</li>
</ol>
<h3 id="26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"><a href="#26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）" class="headerlink" title="26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"></a>26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）</h3><ol>
<li><p>Asynctask：异步任务类，单线程线程池+Handler</p>
</li>
<li><p>线程池：</p>
<ul>
<li>ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。</li>
<li>ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>GC相关：重要</p>
<ul>
<li><p>搜索算法：</p>
<ul>
<li>引用计数</li>
<li>图搜索，可达性分析</li>
</ul>
</li>
<li><p>回收算法：</p>
<ul>
<li>标记清除复制：用于青年代</li>
<li>标记整理：用于老年代</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- 堆分区：

    - 青年区eden 80%、survivor1 10%、survivor2 10%
    - 老年区


- 虚拟机栈分区：

    - 局部变量表
    - 操作数栈
    - 动态链接
    - 方法返回地址

- GC Roots:

    - 虚拟机栈(栈桢中的本地变量表)中的引用的对象
    - 方法区中的类静态属性引用的对象
    - 方法区中的常量引用的对象
    - 本地方法栈中JNI的引用的对象</code></pre><h3 id="27-网络"><a href="#27-网络" class="headerlink" title="27.网络"></a>27.网络</h3><ol>
<li><p>ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p>
</li>
<li><p>HTTP HTTPS的区别:</p>
<ul>
<li><p>HTTPS使用TLS(SSL)进行加密</p>
</li>
<li><p>HTTPS缺省工作在TCP协议443端口</p>
</li>
<li><p>它的工作流程一般如以下方式:</p>
<ul>
<li>完成TCP三次同步握手</li>
<li>客户端验证服务器数字证书，通过，进入步骤3</li>
<li>DH算法协商对称加密算法的密钥、hash算法的密钥</li>
<li>SSL安全加密隧道协商完成</li>
<li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</li>
</ul>
</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>http请求包结构，http返回码的分类，400和500的区别</p>
<ul>
<li><p>包结构：</p>
<ul>
<li>请求：请求行、头部、数据</li>
<li>返回：状态行、头部、数据</li>
</ul>
</li>
<li><p>http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误</p>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>Tcp</p>
<ul>
<li><p>可靠连接，三次握手，四次挥手</p>
<ul>
<li><p>三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源</p>
<ul>
<li>syn-c = x，表示这消息是x序号</li>
<li>ack-s = x + 1，表示syn-c这个消息接收成功。syn-s = y，表示这消息是y序号。</li>
<li>ack-c = y + 1，表示syn-s这条消息接收成功</li>
</ul>
</li>
<li><p>四次挥手：TCP是全双工模式</p>
<ul>
<li>fin-c = x , 表示现在需要关闭c到s了。ack-c = y,表示上一条s的消息已经接收完毕</li>
<li>ack-s = x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭</li>
<li>fin-s = y + 1，表示s已经准备好关闭了，就等c的最后一条命令</li>
<li>ack-c = y + 1，表示c已经关闭，让s也关闭</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- 滑动窗口，停止等待、后退N、选择重传
- 拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复</code></pre><h3 id="28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下"><a href="#28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下" class="headerlink" title="28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下"></a>28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下</h3><h3 id="29-13-APK打包流程和其内容"><a href="#29-13-APK打包流程和其内容" class="headerlink" title="29.13.APK打包流程和其内容"></a>29.13.APK打包流程和其内容</h3><ol>
<li><p>流程</p>
<ul>
<li>aapt生成R文件</li>
<li>aidl生成java文件</li>
<li>将全部java文件编译成class文件</li>
<li>将全部class文件和第三方包合并成dex文件</li>
<li>将资源、so文件、dex文件整合成apk</li>
<li>apk签名</li>
<li>apk字节对齐</li>
</ul>
</li>
<li><p>内容：so、dex、asset、资源文件</p>
</li>
</ol>
<h3 id="30-网络劫持的类型原理：可以百度一下了解一下具体概念"><a href="#30-网络劫持的类型原理：可以百度一下了解一下具体概念" class="headerlink" title="30.网络劫持的类型原理：可以百度一下了解一下具体概念"></a>30.网络劫持的类型原理：可以百度一下了解一下具体概念</h3><ol>
<li>DNS劫持、欺骗、污染</li>
<li>http劫持：重定向、注入js，http注入、报文扩展</li>
</ol>
<h3 id="31-java类加载过程："><a href="#31-java类加载过程：" class="headerlink" title="31.java类加载过程："></a>31.java类加载过程：</h3><ol>
<li>加载时机：创建实例、访问静态变量或方法、反射、加载子类之前</li>
<li>验证：验证文件格式、元数据、字节码、符号引用的正确性</li>
<li>加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象</li>
<li>准备：在堆上为静态变量划分内存</li>
<li>解析：将常量池中的符号引用转换为直接引用</li>
<li>初始化：初始化静态变量</li>
<li>书籍推荐：深入理解java虚拟机，博客推荐：<a href="https://www.jianshu.com/p/bc6d1770d92c" title="Java/Android阿里面试JVM部分理解" target="_blank" rel="noopener">https://www.jianshu.com/p/bc6d1770d92c</a></li>
</ol>
<h3 id="32-retrofit的了解"><a href="#32-retrofit的了解" class="headerlink" title="32.retrofit的了解"></a>32.retrofit的了解</h3><ol>
<li>动态代理创建一个接口的代理类</li>
<li>通过反射解析每个接口的注解、入参构造http请求</li>
<li>获取到返回的http请求，使用Adapter解析成需要的返回值。</li>
</ol>
<h3 id="33-bundle的数据结构，如何存储"><a href="#33-bundle的数据结构，如何存储" class="headerlink" title="33.bundle的数据结构，如何存储"></a>33.bundle的数据结构，如何存储</h3><ol>
<li>键值对储存</li>
<li>传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。</li>
<li>当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口</li>
</ol>
<h3 id="34-listview内点击buttom并移动的事件流完整拦截过程："><a href="#34-listview内点击buttom并移动的事件流完整拦截过程：" class="headerlink" title="34.listview内点击buttom并移动的事件流完整拦截过程："></a>34.listview内点击buttom并移动的事件流完整拦截过程：</h3><ol>
<li><p>点下按钮的时候：</p>
<ul>
<li>产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。</li>
<li>没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表</li>
<li>到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>移动点击按钮的时候:</p>
<ul>
<li>产生move事件，listView中会对move事件做拦截</li>
<li>此时listView会将该滑动事件消费掉</li>
<li>后续的滑动事件都会被listView消费掉</li>
</ul>
</li>
</ol>
<ol start="3">
<li>手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。</li>
</ol>
<h3 id="35-service的意义：不需要界面，在后台执行的程序"><a href="#35-service的意义：不需要界面，在后台执行的程序" class="headerlink" title="35.service的意义：不需要界面，在后台执行的程序"></a>35.service的意义：不需要界面，在后台执行的程序</h3><h3 id="36-android的IPC通信方式，线程（进程间）通信机制有哪些"><a href="#36-android的IPC通信方式，线程（进程间）通信机制有哪些" class="headerlink" title="36.android的IPC通信方式，线程（进程间）通信机制有哪些"></a>36.android的IPC通信方式，线程（进程间）通信机制有哪些</h3><ol>
<li>ipc通信方式：binder、contentprovider、socket</li>
<li>操作系统进程通讯方式：共享内存、socket、管道</li>
</ol>
<h3 id="37-操作系统进程和线程的区别"><a href="#37-操作系统进程和线程的区别" class="headerlink" title="37.操作系统进程和线程的区别"></a>37.操作系统进程和线程的区别</h3><ol>
<li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li>
<li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li>
<li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li>
<li>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</li>
</ol>
<h3 id="38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。"><a href="#38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。" class="headerlink" title="38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。"></a>38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。</h3><ol>
<li><p>简单来说HashMap就是一个会自动扩容的数组链表</p>
</li>
<li><p>put过程</p>
<ul>
<li>对key的hashCode()做hash，然后再计算index;</li>
<li>如果没碰撞直接放到bucket里；</li>
<li>如果碰撞了，以链表的形式存在buckets后；</li>
<li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li>
<li>如果节点已经存在就替换old value(保证key的唯一性)</li>
<li>如果bucket满了(超过load factor*current capacity)，就要resize。</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中</p>
</li>
<li><p>get过程</p>
<ul>
<li>根据key的hash算出数组下表</li>
<li>使用equals遍历链表进行比较</li>
</ul>
</li>
</ol>
<h3 id="39-mvc、mvp、mvvm："><a href="#39-mvc、mvp、mvvm：" class="headerlink" title="39.mvc、mvp、mvvm："></a>39.mvc、mvp、mvvm：</h3><ol>
<li><p>mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖</p>
<ul>
<li>Activity重，很难单元测试</li>
<li>View和Model耦合严重</li>
</ul>
</li>
</ol>
<ol start="2">
<li><p>mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖</p>
<ul>
<li>接口爆炸</li>
<li>Presenter很重</li>
</ul>
</li>
</ol>
<ol start="3">
<li><p>mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。</p>
<ul>
<li>viewModel的业务逻辑可以单独拿来测试</li>
<li>一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类</li>
<li>数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服</li>
</ul>
</li>
</ol>
<h3 id="40-java的线程如何实现"><a href="#40-java的线程如何实现" class="headerlink" title="40.java的线程如何实现"></a>40.java的线程如何实现</h3><ol>
<li>Thread继承</li>
<li>Runnale</li>
<li>Future</li>
<li>线程池</li>
</ol>
<h3 id="41-ArrayList-如何删除重复的元素或者指定的元素；"><a href="#41-ArrayList-如何删除重复的元素或者指定的元素；" class="headerlink" title="41.ArrayList 如何删除重复的元素或者指定的元素；"></a>41.ArrayList 如何删除重复的元素或者指定的元素；</h3><ol>
<li>删除重复：Set</li>
<li>删除指定：迭代器</li>
</ol>
<h3 id="42-如何设计在-UDP-上层保证-UDP-的可靠性传输；"><a href="#42-如何设计在-UDP-上层保证-UDP-的可靠性传输；" class="headerlink" title="42.如何设计在 UDP 上层保证 UDP 的可靠性传输；"></a>42.如何设计在 UDP 上层保证 UDP 的可靠性传输；</h3><ol>
<li>简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。</li>
<li>比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。</li>
<li>基于udp的可靠传输协议有：RUDP、RTP、UDT</li>
</ol>
<h3 id="43-Java-中内部类为什么可以访问外部类"><a href="#43-Java-中内部类为什么可以访问外部类" class="headerlink" title="43.Java 中内部类为什么可以访问外部类"></a>43.Java 中内部类为什么可以访问外部类</h3><ol>
<li>因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去</li>
</ol>
<h3 id="44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树"><a href="#44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树" class="headerlink" title="44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)"></a>44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)</h3><h3 id="45-红黑树特点"><a href="#45-红黑树特点" class="headerlink" title="45.红黑树特点"></a>45.红黑树特点</h3><ol>
<li>root节点和叶子节点是黑色</li>
<li>红色节点后必须为黑色节点</li>
<li>从root到叶子每条路径的黑节点数量相同</li>
</ol>
<h3 id="46-linux异步和同步i-o"><a href="#46-linux异步和同步i-o" class="headerlink" title="46.linux异步和同步i/o:"></a>46.linux异步和同步i/o:</h3><ol>
<li><p>同步：对于client，client一直等待，但是client不挂起：主线程调用</p>
</li>
<li><p>异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调</p>
</li>
<li><p>阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio</p>
</li>
<li><p>非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll</p>
</li>
<li><p>多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。</p>
<ul>
<li>我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。</li>
<li>而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li>
</ul>
</li>
</ol>
<ol start="5">
<li><p>异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。</p>
<ul>
<li>这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。</li>
<li>异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO</li>
</ul>
</li>
</ol>
<h3 id="47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因"><a href="#47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因" class="headerlink" title="47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:"></a>47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:</h3><ol>
<li>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li>
</ol>
<h3 id="48-HandlerThread是什么"><a href="#48-HandlerThread是什么" class="headerlink" title="48.HandlerThread是什么"></a>48.HandlerThread是什么</h3><ol>
<li>MessageQueue + Looper + Handler</li>
</ol>
<h3 id="49-IntentService是什么"><a href="#49-IntentService是什么" class="headerlink" title="49.IntentService是什么"></a>49.IntentService是什么</h3><ol>
<li>含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。</li>
</ol>
<h3 id="50-class和dex"><a href="#50-class和dex" class="headerlink" title="50.class和dex"></a>50.class和dex</h3><ol>
<li>dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。</li>
<li>dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。</li>
<li>class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I/O操作，提高了类的查找速度</li>
</ol>
<h3 id="51-内存泄漏"><a href="#51-内存泄漏" class="headerlink" title="51.内存泄漏"></a>51.内存泄漏</h3><ol>
<li>其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。</li>
<li>例如Handler导致的内存泄漏，Handler就相当于Listener。</li>
<li>在activity关闭的时候注意停止线程，或者将Listener的注册取消</li>
<li>使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收</li>
<li>工具:LeakCanary</li>
</ol>
<h3 id="52-过度绘制、卡顿优化"><a href="#52-过度绘制、卡顿优化" class="headerlink" title="52.过度绘制、卡顿优化:"></a>52.过度绘制、卡顿优化:</h3><ol>
<li><p>过度绘制：</p>
<ul>
<li>移除Window默认的Background：getWidow.setBackgroundDrawable(null);</li>
<li>移除XML布局文件中非必需的Background</li>
<li>减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来)</li>
<li>在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置</li>
<li>工具：HierarchyViewer 查看视图层级</li>
</ul>
</li>
</ol>
<ol start="2">
<li>卡顿优化：16ms数据更新</li>
</ol>
<h3 id="53-apk瘦身"><a href="#53-apk瘦身" class="headerlink" title="53.apk瘦身:"></a>53.apk瘦身:</h3><ol>
<li>classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化</li>
<li>资源文件：通过Lint工具扫描代码中没有使用到的静态资源</li>
<li>图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图</li>
<li>SO文件将不用的去掉，目前主流app一般只放一个arm的so包</li>
</ol>
<h3 id="54-ANR的形成，各个组件上出现ARN的时间限制是多少"><a href="#54-ANR的形成，各个组件上出现ARN的时间限制是多少" class="headerlink" title="54.ANR的形成，各个组件上出现ARN的时间限制是多少"></a>54.ANR的形成，各个组件上出现ARN的时间限制是多少</h3><ol>
<li>只要是主线程耗时的操作就会ARN  如io</li>
<li>broadcast超时时间为10秒  按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒</li>
</ol>
<h3 id="55-Serializable和Parcelable-的区别"><a href="#55-Serializable和Parcelable-的区别" class="headerlink" title="55.Serializable和Parcelable 的区别"></a>55.Serializable和Parcelable 的区别</h3><ol>
<li>P 消耗内存小</li>
<li>网络传输用S  程序内使用P</li>
<li>S将数据持久化方便</li>
<li>S使用了反射 容易触发垃圾回收 比较慢</li>
</ol>
<h3 id="56-Sharedpreferences源码简述"><a href="#56-Sharedpreferences源码简述" class="headerlink" title="56.Sharedpreferences源码简述"></a>56.Sharedpreferences源码简述</h3><ol>
<li>储存于硬盘上的xml键值对，数据多了会有性能问题</li>
<li>ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对</li>
<li>在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据</li>
<li>apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功</li>
<li>多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象.</li>
<li>博客推荐：<a href="https://www.jianshu.com/p/102f25cf64e3" title="全面剖析SharedPreferences" target="_blank" rel="noopener">全面剖析SharedPreferences</a></li>
</ol>
<h3 id="57-操作系统如何管理内存的："><a href="#57-操作系统如何管理内存的：" class="headerlink" title="57.操作系统如何管理内存的："></a>57.操作系统如何管理内存的：</h3><ol>
<li>使用寄存器进行将进程地址和物理内存进行映射</li>
<li>虚拟内存进行内存映射到硬盘上增大内存</li>
<li>虚拟内存是进行内存分页管理</li>
<li>页表实现分页，就是 页+地址偏移。</li>
<li>如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等</li>
<li>博客推荐：<a href="https://www.jianshu.com/p/aecff59430fa" title="现代操作系统部分章节笔记" target="_blank" rel="noopener">现代操作系统部分章节笔记</a></li>
</ol>
<h3 id="58-浏览器输入地址到返回结果发生了什么"><a href="#58-浏览器输入地址到返回结果发生了什么" class="headerlink" title="58.浏览器输入地址到返回结果发生了什么"></a>58.浏览器输入地址到返回结果发生了什么</h3><ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<h3 id="59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"><a href="#59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。" class="headerlink" title="59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"></a>59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。</h3><ol>
<li>发生在编译的时候</li>
<li>PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集</li>
<li>博客推荐：<a href="https://www.jianshu.com/p/4e4751b5bbbb" title="Effective Java笔记（不含反序列化、并发、注解和枚举）" target="_blank" rel="noopener">Effective Java笔记（不含反序列化、并发、注解和枚举</a>、<a href="https://www.jianshu.com/p/6006a3284f55" title="android阿里面试java基础锦集" target="_blank" rel="noopener">android阿里面试java基础锦集</a>、</li>
</ol>
<h3 id="60-activity的生命周期"><a href="#60-activity的生命周期" class="headerlink" title="60.activity的生命周期"></a>60.activity的生命周期</h3><ol>
<li>a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume</li>
<li>意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。</li>
</ol>
<h3 id="61-面试常考的算法"><a href="#61-面试常考的算法" class="headerlink" title="61.面试常考的算法"></a>61.面试常考的算法</h3><ol>
<li>快排、堆排序为首的各种排序算法</li>
<li>链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点</li>
<li>二叉树、红黑树、B树定义以及时间复杂度计算方式</li>
<li>动态规划、贪心算法、简单的图论</li>
<li>推荐书籍：算法导论，将图论之前的例子写一遍</li>
</ol>
<h3 id="62-Launcher进程启动另外一个进程的过程：启动一个app"><a href="#62-Launcher进程启动另外一个进程的过程：启动一个app" class="headerlink" title="62.Launcher进程启动另外一个进程的过程：启动一个app"></a>62.Launcher进程启动另外一个进程的过程：<a href="http://www.cnblogs.com/tiantianbyconan/p/5017056.html" title="启动一个app" target="_blank" rel="noopener">启动一个app</a></h3><h3 id="63-开源框架源码"><a href="#63-开源框架源码" class="headerlink" title="63.开源框架源码"></a>63.开源框架源码</h3><ol>
<li><p>Fresco</p>
<ul>
<li><p>mvc框架：</p>
<ul>
<li>Controller控制数据显示在Hierarchy中的Drawable的显隐</li>
<li>ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage</li>
<li>Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- Drawable层次以及绘制：

    - 如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw()
    - Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制)
    - ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的
    - webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的


- 职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片--》解码图片缓存Producer--》后台线程Producer--》client图片处理producer(n)--》解码producer(n)--》旋转或剪裁producer(n)--》编码图片内存缓存producer--》读硬盘缓存producer--》写硬盘缓存producer(n)--》网络producer提供CloseableImage《--解码图片缓存consumer《--client图片处理consumer《--解码consumer《--旋转或剪裁consumer《--编码图片内存缓存consumer《--写硬盘缓存consumer《--图片数据
- 内存缓存：

    - 一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。
    - 这里的引用计数是用Fresco组件实现的引用计数器。
    - 缓存有一个代理类，用来追踪缓存的存取。
    - CountingLruMap是使用LinkedHashMap来储存数据的。


- 硬盘缓存：

    - DefaultDiskStorage使用Lru策略。
    - 为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散
    - DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。
    - 删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。
    - 在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。
    - 使用了java提供的FileTreeVisitor来遍历文件


- 对象池：

    - 使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组
    - 申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存


7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者
8.自定义计数引用：类似c++智能指针

    1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt;
    2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。
    3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。


9.博客推荐：Android Fresco源码文档翻译、从零开始撸一个Fresco之硬盘缓存、从零开始撸一个Fresco之gif和Webp动画、从零开始撸一个Fresco之内存缓存、从零开始撸一个Fresco之总结</code></pre><ol start="2">
<li><p>oKhttp：</p>
<ul>
<li><p>同步和异步：</p>
<p>  1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。<br>  2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。</p>
</li>
</ul>
</li>
</ol>
<pre><code>- 连接池：

    - 一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位
    - 当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。
    - ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket


- 选择路线与建立连接

    - 选择路线有两种方式：

        - 无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源
        - 有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口
        - 代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。


    - 建立连接

        - 连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步
        - 根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手
        - 将建立成功的RealConnection放入(put)连接池缓存
        - 如果存在TLS，就根据SSL版本与证书进行安全握手
        - 构造HttpStream并维护刚刚的socket连接，管道建立完成




- 职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题
- 博客推荐：[Android数据层架构的实现 上篇](https://www.jianshu.com/p/60e5ebf0096a &quot;Android数据层架构的实现 上篇&quot;)、[Android数据层架构的实现 下篇](https://www.jianshu.com/p/5def7b42d223 &quot;Android数据层架构的实现 下篇&quot;)</code></pre><ol start="3">
<li><p>okio</p>
<ul>
<li><p>简介；</p>
<ul>
<li>sink：自己–》别人</li>
<li>source：别人–》自己</li>
<li>BufferSink：有缓存区域的sink</li>
<li>BufferSource：有缓存区域的source</li>
<li>Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>- 比java io的好处：

    - 减少内存申请和数据拷贝
    - 类少，功能齐全，开发效率高


- 内部实现：

    - Buffer的Segment双向链表，减少数据拷贝
    - Segment的内部byte数组的共享，减少数据拷贝
    - SegmentPool的共享和回收Segment
    - sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source
    - 最终okio只是对java io的封装，所有操作都是基于java io 的</code></pre><hr>
<pre><code>作者：何时夕
链接：https://www.jianshu.com/p/cf5092fa2694
來源：简书</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/hexo常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/hexo常用命令/" itemprop="url">hexo常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-14T16:18:14+08:00">
                2019-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index">
                    <span itemprop="name">Hexo</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>以下命令需要在本地Blog路径下执行</p>
<h2 id="Step1-创建文章"><a href="#Step1-创建文章" class="headerlink" title="Step1 创建文章"></a>Step1 创建文章</h2><pre><code>$ hexo new &quot;My New Post&quot;
$ hexo n &quot;My New Post&quot;    //安装hexo-asset-image后可使用</code></pre><h2 id="Step2-编辑文章"><a href="#Step2-编辑文章" class="headerlink" title="Step2 编辑文章"></a>Step2 编辑文章</h2><pre><code>文章头部加
---
title: //此处填写文章名
date: //此处填写发布日期
tags: 
  - //此处填写标签名(可多个)
---</code></pre><p>由于在首页中显示文章内容使用的是 post.content 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/record/hexo常用命令/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </p></div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/Android获取Imageview上的图片/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/Android获取Imageview上的图片/" itemprop="url">Android获取Imageview上的图片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T09:24:15+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Android获取Imageview上的图片"><a href="#Android获取Imageview上的图片" class="headerlink" title="Android获取Imageview上的图片"></a>Android获取Imageview上的图片</h2><pre><code>private Bitmap view2Bitmap(ImageView imageView) {
    imageView.setDrawingCacheEnabled(true);
    imageView.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
    imageView.layout(0, 0, imageView.getMeasuredWidth(), imageView.getMeasuredHeight());
    imageView.buildDrawingCache();
    Bitmap bitmap = Bitmap.createBitmap(imageView.getDrawingCache());
    imageView.setDrawingCacheEnabled(false);
    return bitmap;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/AutoSearchBug/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/AutoSearchBug/" itemprop="url">AutoSearchBug自动联网查找bug</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-03T10:15:44+08:00">
                2018-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/AutoSearchBug/" itemprop="url" rel="index">
                    <span itemprop="name">AutoSearchBug</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>这是一款可以在项目崩溃时获取异常<br>自动联网在Stack Overflow,百度或其他平台上寻找回答链接和详情</p>
</blockquote>
<hr>
<blockquote>
<p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80900149" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80900149</a><br>简书:<a href="https://www.jianshu.com/p/625519ce9f8a" target="_blank" rel="noopener">https://www.jianshu.com/p/625519ce9f8a</a><br>Github:<a href="https://github.com/SHPDZY/AutoSearchBug" target="_blank" rel="noopener">https://github.com/SHPDZY/AutoSearchBug</a></p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>android通过UncaughtExceptionHandler来实现获取应用全局的crash信息<br>启动一个服务来完成联网查找回答</p>
<pre><code>Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {
    public void uncaughtException(final Thread thread, final Throwable ex) {
        String errorMsg = getErrorMsg(ex);
        Intent intent = new Intent(mApp, AutoSearchBugService.class);
        intent.putExtra(ERROR_MSG, errorMsg);
        intent.putExtra(MAX_SIZE, maxSize);
        intent.putExtra(SHOW_ANSWER, showAnswer);
        intent.putExtra(SEARCH_TYPE, searchType);
        mApp.startService(intent);
        mUEH.uncaughtException(thread, ex);
    }
};

public class AutoSearchBugService extends Service implements AutoSearchBugGlobal {

    ···

    private void search(final String errorMsg, int maxSize, final int showAnswer, int searchType) {
        AutoSearchBugHttpUtil.doGet(
                        AutoSearchBugAPI.SEARCH_URL + 
                        AutoSearchBugAPI.PAGE_SIZE + maxSize +
                        AutoSearchBugAPI.ERROR_MSG + errorMsg.replace(&quot; &quot;, &quot;%20&quot;) +
                        AutoSearchBugAPI.SHOW_ANSWER + showAnswer + 
                        AutoSearchBugAPI.SEARCH_TYPE + searchType,
                new AutoSearchBugHttpUtil.HResponse() {
                    @Override
                    public void onStart() {
                        StringBuffer log = new StringBuffer();
                        log.append(LINE_START);
                        log.append(SEARCHING);
                        log.append(LINE_END);
                        log(log);
                    }

                    @Override
                    public void onFinish(String msg) {
                        resolveLog(msg, errorMsg, showAnswer);
                        stopSelf();
                    }

                    @Override
                    public void onError(String error) {
                        StringBuffer log = new StringBuffer();
                        log.append(String.format(ASB_ERROR, error));
                        log.append(LINE_END);
                        log(log);
                        stopSelf();
                    }
                });
    }

···

}</code></pre><p>服务端通过Jsoup来解析html</p>
<pre><code>@RestController
@RequestMapping(&quot;/android&quot;)
@Api(&quot;android接口&quot;)
public class SearchBugApi {

    ···

    /**
     * 通过errorMsg来查找回答
     * @param page          获取几条数据
     * @param errorMsg      crash信息
     * @param showAnswer    是否显示回答详情
     * @param type          0搜索stackoverflow 1搜索baidu
     * @return
     */
    @GetMapping(&quot;autosearchbug&quot;)
    public R autosearchbug(int page, String errorMsg, int showAnswer, int type) {
        switch (type) {
            case 0:
                return getStackOverFlow(page, errorMsg, showAnswer);
            case 1:
                return getBD(page, errorMsg);
            default:
                return getStackOverFlow(page, errorMsg, showAnswer);
        }

    }

     private R getStackOverFlow(int page, String errorMsg, int showAnswer) {
        String url = &quot;https://stackoverflow.com/search?q=&quot; + errorMsg;
        List&lt;AutoSearchBugEntity&gt; autoSearchBugList = new ArrayList();
        try {
            Document doc = Jsoup.connect(url).get();
            ···
            return R.ok().putData(autoSearchBugList);
        } catch (IOException e) {
            e.printStackTrace();
            return R.error(e.getMessage());
        }
    }


    ···

}</code></pre><h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><h3 id="Android-Studio-引入"><a href="#Android-Studio-引入" class="headerlink" title="Android Studio 引入"></a>Android Studio 引入</h3><h4 id="第1步-将JitPack存储库添加到您的构建文件"><a href="#第1步-将JitPack存储库添加到您的构建文件" class="headerlink" title="第1步 将JitPack存储库添加到您的构建文件"></a>第1步 将JitPack存储库添加到您的构建文件</h4><p>将其添加到存储库末尾的根build.gradle中：</p>
<pre><code>allprojects {
     repositories {
         ...
         maven { url &apos;https://jitpack.io&apos; }
     }
 }</code></pre><h4 id="第2步-添加依赖关系"><a href="#第2步-添加依赖关系" class="headerlink" title="第2步 添加依赖关系"></a>第2步 添加依赖关系</h4><pre><code>dependencies {
       implementation &apos;com.github.SHPDZY:AutoSearchBug:1.0.1&apos;
}</code></pre><h3 id="Eclipse-引入"><a href="#Eclipse-引入" class="headerlink" title="Eclipse 引入"></a>Eclipse 引入</h3><p>建议使用As，方便版本更新。</p>
<pre><code>dependencies {
       compile project(path: &apos;:AutoSearchBug&apos;)
}</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code>AutoSearchBugControl.getBuilder()
        .setMaxSize(3)    //显示数量
        .showAnswer(true) //true显示回答详情
        .setSearchType(0) //0在stackoverflow搜索  1：在百度搜索
        .init();</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>默认初始化未显示回答详情<br><img src="http://blog.9aiplay.com/zb_users/upload/2018/07/20180703150844153060172493277.png" alt="效果图"></p>
<p>自定义初始化显示详情<br><img src="http://blog.9aiplay.com/zb_users/upload/2018/07/20180703145628153060098854731.png" alt="效果图"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/common-android-ui-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/common-android-ui-library/" itemprop="url">Android常用UI库(来源网络)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T10:06:50+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/Ui库/" itemprop="url" rel="index">
                    <span itemprop="name">Ui库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>收集Android常用的Ui库</p>
</blockquote>
<hr>
<blockquote>
<p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80901082" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80901082</a><br>简书:<a href="https://www.jianshu.com/p/baa34723c64b" target="_blank" rel="noopener">https://www.jianshu.com/p/baa34723c64b</a><br>Github:<a href="https://github.com/SHPDZY/CommonViewForAndroid" target="_blank" rel="noopener">https://github.com/SHPDZY/CommonViewForAndroid</a></p>
</blockquote>
<h1 id="PickTime"><a href="#PickTime" class="headerlink" title="PickTime"></a>PickTime</h1><p>日期选择控件<br>项目地址:<br><a href="https://github.com/codbking/PickTime" target="_blank" rel="noopener">https://github.com/codbking/PickTime</a><br><img src="../common-android-ui-library/1.gif" alt></p>
<hr>
<h1 id="Android-PickerView"><a href="#Android-PickerView" class="headerlink" title="Android-PickerView"></a>Android-PickerView</h1><p>这是一款仿iOS的PickerView控件，有时间选择器和选项选择器<br>项目地址:<br><a href="https://github.com/Bigkoo/Android-PickerView" target="_blank" rel="noopener">https://github.com/Bigkoo/Android-PickerView</a><br><img src="../common-android-ui-library/2.gif" alt></p>
<hr>
<h1 id="MPAndroidChart"><a href="#MPAndroidChart" class="headerlink" title="MPAndroidChart"></a>MPAndroidChart</h1><p>强大的Android图表视图/图形视图库<br>项目地址:<br><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a><br><img src="../common-android-ui-library/3-1.png" alt><br><img src="../common-android-ui-library/3-2.png" alt><br><img src="../common-android-ui-library/3-3.png" alt></p>
<hr>
<h1 id="PhotoView"><a href="#PhotoView" class="headerlink" title="PhotoView"></a>PhotoView</h1><p>实现支持缩放的ImageView for Android。<br>项目地址:<br><a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">https://github.com/chrisbanes/PhotoView</a><br><img src="../common-android-ui-library/4-1.png" alt><br><img src="../common-android-ui-library/4-2.png" alt></p>
<hr>
<h1 id="CircleImageView"><a href="#CircleImageView" class="headerlink" title="CircleImageView"></a>CircleImageView</h1><p>适用于Android的圆形ImageView<br>项目地址:<br><a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a><br><img src="../common-android-ui-library/5.png" alt></p>
<hr>
<h1 id="AVLoadingIndicatorView"><a href="#AVLoadingIndicatorView" class="headerlink" title="AVLoadingIndicatorView"></a>AVLoadingIndicatorView</h1><p>这是一款Android的精彩加载动画的集合，虽然作业已经弃用，但还是一个有助于学习的项目<br>项目地址:<br><a href="https://github.com/81813780/AVLoadingIndicatorView" target="_blank" rel="noopener">https://github.com/81813780/AVLoadingIndicatorView</a><br><img src="../common-android-ui-library/6.gif" alt></p>
<hr>
<h1 id="MaterialViewPager"><a href="#MaterialViewPager" class="headerlink" title="MaterialViewPager"></a>MaterialViewPager</h1><p>一款Material Design ViewPager<br>项目地址:<br><a href="https://github.com/florent37/MaterialViewPager" target="_blank" rel="noopener">https://github.com/florent37/MaterialViewPager</a><br><img src="../common-android-ui-library/7.png" alt></p>
<hr>
<h1 id="JiaoZiVideoPlayer"><a href="#JiaoZiVideoPlayer" class="headerlink" title="JiaoZiVideoPlayer"></a>JiaoZiVideoPlayer</h1><p>一款简单强大方便自定义的播放器<br>项目地址:<br><a href="https://github.com/lipangit/JiaoZiVideoPlayer" target="_blank" rel="noopener">https://github.com/lipangit/JiaoZiVideoPlayer</a><br><img src="../common-android-ui-library/8.png" alt></p>
<hr>
<h1 id="UltimateRecyclerView"><a href="#UltimateRecyclerView" class="headerlink" title="UltimateRecyclerView"></a>UltimateRecyclerView</h1><p>一个多功能的RecycleView，带有拉动刷新，加载更多，滑动解散，拖放和动画，粘滞标题，滚动显示或隐藏工具栏和FAB等许多功能。<br>项目地址:<br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">https://github.com/cymcsg/UltimateRecyclerView</a><br><img src="../common-android-ui-library/9.gif" alt>)<img src="../common-android-ui-library/9-4.gif" alt>)<img src="../common-android-ui-library/9-2.gif" alt>)<img src="../common-android-ui-library/9-3.gif" alt></p>
<hr>
<h1 id="RoundedImageView"><a href="#RoundedImageView" class="headerlink" title="RoundedImageView"></a>RoundedImageView</h1><p>一款简单的ImageView，支持圆角，椭圆和圆形。<br>项目地址:<br><a href="https://github.com/vinc3m1/RoundedImageView" target="_blank" rel="noopener">https://github.com/vinc3m1/RoundedImageView</a><br><img src="../common-android-ui-library/10.png" alt></p>
<hr>
<h1 id="XRecyclerView"><a href="#XRecyclerView" class="headerlink" title="XRecyclerView"></a>XRecyclerView</h1><p>一款可以添加head实现了pullrefresh，loadingmore的简单方便的RecycleView<br>项目地址:<br><a href="https://github.com/XRecyclerView/XRecyclerView" target="_blank" rel="noopener">https://github.com/XRecyclerView/XRecyclerView</a><br><img src="../common-android-ui-library/11.gif" alt></p>
<hr>
<h1 id="持续更新中······"><a href="#持续更新中······" class="headerlink" title="持续更新中······"></a>持续更新中······</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/独立服务器自建Git仓库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/独立服务器自建Git仓库/" itemprop="url">独立服务器自建Git仓库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T10:54:18+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code>环境：  
服务器 CentOS7.3 + git（version 1.8..31）
客户端 Windows7 + git（version 2.16.2.windows.1）</code></pre><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>Linux 做为服务器端系统，Windows 作为客户端系统，分别安装 Git</p>
<h3 id="服务器端安装"><a href="#服务器端安装" class="headerlink" title="服务器端安装"></a>服务器端安装</h3><pre><code>[root@VM_0_16_centos ~]# yum install -y git  </code></pre><p>安装完后，查看 Git 版本</p>
<pre><code>[root@VM_0_16_centos ~]# git --version  
git version 1.8.3.1</code></pre><h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><p>下载    <a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git for Windows</a></p>
<p>安装完之后，可以使用 Git Bash 作为命令行客户端。</p>
<p>安装完之后，查看 Git 版本</p>
<blockquote>
<p>$ git –version<br>git version 2.16.2.windows.1</p>
</blockquote>
<h2 id="服务器端创建-git-用户，用来管理-Git-服务，并为-git-用户设置密码"><a href="#服务器端创建-git-用户，用来管理-Git-服务，并为-git-用户设置密码" class="headerlink" title="服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码"></a>服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码</h2><pre><code>[root@localhost home]# id git
id: git：no such user
[root@localhost home]# useradd git
[root@localhost home]# passwd git</code></pre><h2 id="服务器端创建-Git-仓库"><a href="#服务器端创建-Git-仓库" class="headerlink" title="服务器端创建 Git 仓库"></a>服务器端创建 Git 仓库</h2><p>设置 /home/data/git/gittest.git 为 Git 仓库</p>
<p>然后把 Git 仓库的 owner 修改为 git</p>
<pre><code>[root@localhost home]# mkdir -p data/git/gittest.git
[root@localhost home]# git init --bare data/git/gittest.git
Initialized empty Git repository in /home/data/git/gittest.git/
[root@localhost home]# cd data/git/
[root@localhost git]# chown -R git:git gittest.git/</code></pre><h2 id="客户端-clone-远程仓库"><a href="#客户端-clone-远程仓库" class="headerlink" title="客户端 clone 远程仓库"></a>客户端 clone 远程仓库</h2><p>在硬盘里找一个文件夹来存放，然后从 Linux Git 服务器上 clone 项目</p>
<blockquote>
<p>$ git clone <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a>:/home/data/gittest.git</p>
</blockquote>
<p><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/git_clone.png" alt="git clone"></p>
<p>当第一次连接到目标 Git 服务器时会得到一个提示：</p>
<blockquote>
<p>The authenticity of host ‘192.168.56.101 (192.168.56.101)’ can’t be established.<br>RSA key fingerprint is SHA256:Ve6WV/SCA059EqoUOzbFoZdfmMh3B259nigfmvdadqQ.<br>Are you sure you want to continue connecting (yes/no)? </p>
</blockquote>
<p>选择 yes：</p>
<blockquote>
<p>Warning: Permanently added ‘192.168.56.101’ (RSA) to the list of known hosts.</p>
</blockquote>
<p>此时 C:\Users\用户名.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句。<br><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/known.png" alt="known"></p>
<h2 id="客户端创建-SSH-公钥和私钥"><a href="#客户端创建-SSH-公钥和私钥" class="headerlink" title="客户端创建 SSH 公钥和私钥"></a>客户端创建 SSH 公钥和私钥</h2><blockquote>
<p>$ ssh-keygen -t rsa -C “<a href="mailto:472323087@qq.com" target="_blank" rel="noopener">472323087@qq.com</a>“</p>
</blockquote>
<p><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/ssh-keygen.png" alt></p>
<p>此时 C:\Users\用户名.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub</p>
<p>id_rsa 是私钥</p>
<p>id_rsa.pub 是公钥</p>
<h2 id="服务器端-Git-打开-RSA-认证"><a href="#服务器端-Git-打开-RSA-认证" class="headerlink" title="服务器端 Git 打开 RSA 认证"></a>服务器端 Git 打开 RSA 认证</h2><p>进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：</p>
<pre><code>RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys</code></pre><p>保存并重启 sshd 服务：</p>
<pre><code>[root@localhost ssh]# service sshd restart</code></pre><p>由 AuthorizedKeysFile 得知公钥的存放路径是 .ssh/authorized_keys，实际上是 $Home/.ssh/authorized_keys，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 /home/git/.ssh/authorized_keys</p>
<p>在 /home/git/ 下创建目录 .ssh</p>
<pre><code>[root@localhost git]# cd /home/git/  
[root@localhost git]# pwd  
/home/git  
[root@localhost git]# mkdir .ssh  
[root@localhost git]# ls -a   
. .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla .ssh</code></pre><p>然后把 .ssh 文件夹的 owner 修改为 git</p>
<pre><code>[root@localhost git]# chown -R git:git .ssh  
[root@localhost git]# ll -a  
总用量 32  
drwx------. 5 git  git  4096 8月  28 20:04 .  
drwxr-xr-x. 8 root root 4096 8月  28 19:32 ..  
-rw-r--r--. 1 git  git18 10月 16 2014 .bash_logout  
-rw-r--r--. 1 git  git   176 10月 16 2014 .bash_profile  
-rw-r--r--. 1 git  git   124 10月 16 2014 .bashrc  
drwxr-xr-x. 2 git  git  4096 11月 12 2010 .gnome2  
drwxr-xr-x. 4 git  git  4096 5月   8 12:22 .mozilla  </code></pre><blockquote>
<p>drwxr-xr-x. 2 git  git  4096 8月  28 20:08 .ssh  </p>
</blockquote>
<h2 id="将客户端公钥导入服务器端-home-git-ssh-authorized-keys-文件"><a href="#将客户端公钥导入服务器端-home-git-ssh-authorized-keys-文件" class="headerlink" title="将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件"></a>将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件</h2><p>回到 Git Bash 下，导入文件：</p>
<blockquote>
<p>$ ssh <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a> ‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p>
</blockquote>
<p>需要输入服务器端 git 用户的密码</p>
<p>或或者用FileZilla类似软件直接复制</p>
<pre><code>[root@localhost .ssh]# cd /home/git/.ssh/  
[root@localhost .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><p>回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件：</p>
<pre><code>[root@localhost git]# cd .ssh  
[root@localhost .ssh]# ll  
总用量 4  
-rw-rw-r--. 1 git git 398 8月  28 20:08 authorized_keys</code></pre><p>可以查看一下是否是客户端生成的公钥。</p>
<p>重要：</p>
<p>修改 .ssh 目录的权限为 700</p>
<p>修改 .ssh/authorized_keys 文件的权限为 600</p>
<pre><code>[root@localhost git]# chmod 700 .ssh  
[root@localhost git]# cd .ssh  
[root@localhost .ssh]# chmod 600 authorized_keys   </code></pre><h2 id="客户端再次-clone-远程仓库"><a href="#客户端再次-clone-远程仓库" class="headerlink" title="客户端再次 clone 远程仓库"></a>客户端再次 clone 远程仓库</h2><blockquote>
<p>$ git clone <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a>:/home/data/git/gittest.git</p>
</blockquote>
<p>项目已经成功 clone 了。</p>
<h2 id="将git仓库文件自动同步到nginx文件目录下，可以通过外网访问"><a href="#将git仓库文件自动同步到nginx文件目录下，可以通过外网访问" class="headerlink" title="将git仓库文件自动同步到nginx文件目录下，可以通过外网访问"></a>将git仓库文件自动同步到nginx文件目录下，可以通过外网访问</h2><pre><code>[root@localhost git]# cd /home/data/git/gittest.git
[root@localhost git]# touch post-receive
[root@localhost git]# vi post-receive</code></pre><p>编辑这个 post-receive 文件：</p>
<pre><code>/#!/bin/bash -l
GIT_REPO=/home/data/git/gittest.git  
TMP_GIT_CLONE=/home/data/git/gittest_tmp  
PUBLIC_WWW=/home/data/git/gittest  
rm -rf ${TMP_GIT_CLONE}  
git clone $GIT_REPO $TMP_GIT_CLONE
rm -rf ${PUBLIC_WWW}/*  
cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}</code></pre><p>这个脚本可以实现完全更新，即先删除原网站内所有内容，再拷贝新仓库内容到网站目录，可以避免一些不必要的问题。</p>
<p>还要给脚本加上执行权限：</p>
<pre><code>[root@localhost git]# chmod +x post-receive</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/LogCatDialog-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/LogCatDialog-0/" itemprop="url">LogCatDialog</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T12:30:45+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/View/" itemprop="url" rel="index">
                    <span itemprop="name">View</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>一款可以在手机中打开logcat控制台</p>
</blockquote>
<hr>
<blockquote>
<p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80900233" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80900233</a><br>简书:<a href="https://www.jianshu.com/p/32837cb6ee7e" target="_blank" rel="noopener">https://www.jianshu.com/p/32837cb6ee7e</a><br>Github:<a href="https://github.com/SHPDZY/LogCatDialog" target="_blank" rel="noopener">https://github.com/SHPDZY/LogCatDialog</a></p>
</blockquote>
<ul>
<li>方便快捷</li>
<li>支持内容搜索</li>
<li>支持自定义标题</li>
<li>支持根据tag筛选</li>
<li>支持根据log级别显示</li>
</ul>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/record/LogCatDialog-0/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://shpdzy.github.io/record/Activity的4种启动模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangyong">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张永的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/record/Activity的4种启动模式/" itemprop="url">Activity的4种启动模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T12:09:22+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Activity4种启动模式"><a href="#Activity4种启动模式" class="headerlink" title="Activity4种启动模式"></a>Activity4种启动模式</h2><ul>
<li>standard</li>
<li>singleTop</li>
<li>singleTask</li>
<li>singleInstance</li>
</ul>
<p>下面我来分别做介绍。</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>顾名思义，standard英文意思就是“标准的”。</p>
<p>也就是说这种启动模式是默认的，我们平时在开发中使用最多的就是Standard模式的。</p>
<p>如果一个Activity的启动模式被设置成standard，那么它可以无限制的创建。你每一次通过Intent去启动这种模式的Activity都会重新创建一个。</p>
<p>大家可以想象一下邮箱里的收件箱（假设我们将打开邮件的Activity的启动模式设置为Standard，当然这也是默认的模式）里有10封邮件。我们给查看邮件的Activity起名为CheckEmailActivity,我点击第一封邮件将会打开一个CheckEmailActivity，当我看完之后点击下一封邮件，另一个CheckEmailActivity又会被创建，这样如果我们将10封邮件全部看完，那在Activity任务栈中将会有10个CheckEmailActivity，而且如果我想回到收件箱页面还必须点10次返回键！想想是不是很可怕？</p>
<p>所以说standard模式虽然很常用，但也不是适用于任何场合。<br>　　<br>另外说一点，standard模式在Android 5.0（Lollipop）之前和之后是有区别的。<br>　　<br><strong>Android Lollipop之前</strong></p>
<p>standard模式的Activity总是会被创建在启动它的Activity同一个任务栈中顶端（任务栈是一个栈结构，先进后出 First In Last Out），就算他们来自不同的应用。<br>　　<br>想象一个场景，如果你在A应用中要分享一个本地图片，这样会打开系统的图片查看应用中的图片选择器Activity，虽然这两个Activity来自不同的应用，但Android系统仍将会把他们放在同一个任务栈中，即A应用的任务栈中。<br>　　<br><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/1.png" alt></p>
<p><strong>Android Lollipop之后</strong></p>
<p>如果将要启动的Activity和启动它的Activity来自同一个应用，那没话说，和Lollipop之前一样，新的Activity会被创建在当前任务栈中的顶端。</p>
<p>但是如果它们来自不同的应用，那就会创建一个新的任务栈，再把要启动的Activity放在新的任务栈中，这时这个新启动的Activity就是新创建的任务站点的根Activity。如下图所示：<br>　　<br><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/2.png" alt></p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>顾名思义，singleTop的意思就是“在顶部只能有一个”。</p>
<p>这种启动模式非常类似于standard，但是也有一些 区别：</p>
<p>如果在启动这种模式的Activity的时候，当前任务栈的顶端已经存在了相同的Activity，那系统就不会再创建新的，而是回调任务栈中已经存在的该Activity的onNewIntent( )方法。请看下面的示意图：</p>
<p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/3.png" alt></p>
<p>也正因为SingleTop启动模式的特殊性，所以在开发时，如果指定了一个Activity的启动模式是singleTop的那就应该既要重写onCreated()方法用于应对第一次创建的情况，也要重写onNewIntent( )方法来应对重复创建的情况。<br>其实大家可以想象一下，这种启动模式的应用场景。Android既然提供了这种启动模式，说明肯定有应有场景需要这样的方式。其实最常用的场景就是搜索，比方说我们在搜索框中输入想要搜索的内容点击搜索进入SearchResultActivty(搜索结果页)查看搜索的结果（一般我们也会在搜索结果页提供搜索框，这样用户无需点击返回键回到上一个页面再在搜索框中输入搜索内容点击搜索），如果此时用户还想搜点别的东西，就可以直接在当前的搜索结果页SearchResultActivty中的搜索框输入搜索内容继续搜索。</p>
<p>大家想象一下，如果我们把SearchResultActivty的启动模式设置为Standard的话会是什么样的景象。比如我们连着搜了10个内容，那就会启动10个不同的SearchResultActivty，然而这些SearchResultActivty功能完全一样，完全没有必要创建这么多，而且还有一个和上一节中的邮箱一样的问题，就是用户搜索结束想回到首页，那就还得按10次返回键才能回到首页，- -！</p>
<p>这时，singleTop启动模式就派上用场了，我们首先把SearchResultActivty的启动模式设置为singleTop，这样用户在SearchResultActivty页面中继续搜索的时候，我们只需把用户要搜索的内容放在Intent里面然后启动SearchResultActivty，这时系统并不会重新创建新的SearchResultActivty，而是回调当前任务栈栈顶的SearchResultActivty的onNewIntent()方法来接收带有用户搜索内容信息的Intent，然后我们拿到用户搜索内容后调搜索接口，并根据接口返回内容重新刷新布局即可，似不似很神奇？其实我们在上一节提到的邮箱的问题，也是用这种方式来解决的，原理和搜索一样的。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>这种启动模式的Activity在Android系统中只允许存在一个实例。</p>
<p>如果系统中已经存在了该种启动模式的目标Activity，则系统并不会重新创建一个目标Activity，而是首先将持有目标Activity的整个任务栈都会被置于前台（用户可见），并且通过onNewIntent( )方法将启动目标Activity的Intent传递给目标Activity，置于目标Activity拿到这个Intent之后要做什么操作，系统就不管了，随便你拿来干什么，哼~。</p>
<p>但是这里有个问题，就是目标Activity和源Activity是不是来自同一应用。</p>
<p>源Activity和目标Activity来自同一个应用<br>这种情况还要分两种情况说：</p>
<p>当前系统中还没有目标Activity的实例<br>这种情况最简单，直接在当前的任务栈中创建SingleTask模式的Activity并置于栈顶即可。</p>
<p>当前系统中已经存在目标Activity的实例<br>这种情况比较特殊，因为系统会把任务栈中目标Activity之上的所有Activity销毁，以让目标Activity处在栈顶的位置。</p>
<p>这里还要还要再提醒大家的是，因为目标Activity已经存在，系统不会重新创建，而是通过onNewIntent()的方式把Intent传递过来，这点和singleTop模式有些类似。注意了，这里让我们回想一下文章开头的我所说的场景，如何让用户在支付完成页直接跳转到首页，并把不需要的Activity销毁？SingleTask启动模式是不是刚好和我们的需求一致？请看下面的示意图：</p>
<p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/4.png" alt></p>
<p><strong>源Activity和目标Activity来自不同应用</strong><br>这种情况也要分两种情况说：</p>
<p><strong>当前系统中还没有目标Activity的实例</strong><br>这时系统首先会看任务管理器中是否有目标Actvity所在应用的任务栈？如果有的话，那就直接在目标Activity所在应用的任务栈的栈顶创建即可。</p>
<p>如果任务管理器中没有目标Activity所在应用的任务栈，系统就会创建其所在应用的任务栈和目标Activity，并且把目标Activity作为新建任务栈的根Activity。如下图所示：
　　</p>
<p><strong>当前系统中已经存在目标Activity的实例</strong><br>目标Activity所在任务栈会被置于前台（即用户可见），而且也会把目标Activity之上的所有Actvity全部销毁。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>这种启动模式和singleTask<strong>几乎一样</strong>，它也只允许系统中存在一个目标Activity，包括上面我们所说的SingleTask的一些特性singleInstance都有。<strong>唯一不同的是，持有目标Activity的任务栈中只能有目标Activity一个Actvitiy，不能再有别的Activity，对！ 就是承包了这个任务栈！。</strong></p>
<p>其实从这种启动模式的名字也可以看出来它表示的意思，singleInstance直译过来就是“单一实例”，什么意思呢？这话啊有两层意思，我来给你分析分析：1. 跟系统说，“我是独一无二的，不许和我一样的人存在！”，这就是说系统中存在一个目标Activity。；2. 跟任务栈说，“我是独一无二的，不许你心里再装别的人！”，这就是说持有目标Activity的任务栈中只能有目标Activity一个Activity。这样说是不是好理解一些，哈哈~<br>　　<br>所以，如果要启动singleInstance模式的Activity,那只能新创建一个任务栈用来放它，因为人家说了，“我是独一无二的！”。同样的，如果从这种启动模式的Activity中启动别的Activity，那不好意思，我不管你是不是和我处在同一个应用，我所在的任务栈只能拥有我一个人，您呐，另外让系统给你创建一个任务栈待着去吧。</p>
<p>好了，至此我们介绍了Activity的4种启动模式了，也大致了解了每种启动模式的特点了，那接下里的问题就是怎么使用呢？问题又抛出来了，好，让我们接着往下看。</p>
<h2 id="怎么使用启动模式？"><a href="#怎么使用启动模式？" class="headerlink" title="怎么使用启动模式？"></a>怎么使用启动模式？</h2><p>有两种方式来使用或者说设置Activity的启动模式：</p>
<h3 id="方式1：在AndroidMenifest-xml文件中设置："><a href="#方式1：在AndroidMenifest-xml文件中设置：" class="headerlink" title="方式1：在AndroidMenifest.xml文件中设置："></a>方式1：在AndroidMenifest.xml文件中设置：</h3><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/5.png" alt></p>
<p>看到没有，在<activity>标签中设置android:launchMode=”<strong><strong>“属性即可，</strong></strong>即我们上面所说的四种启动模式。</activity></p>
<h3 id="方式2：通过为Intent添加标识来设置"><a href="#方式2：通过为Intent添加标识来设置" class="headerlink" title="方式2：通过为Intent添加标识来设置"></a>方式2：通过为Intent添加标识来设置</h3><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/6.png" alt></p>
<p>看到没有，这里使用Intent的addFlags()方法来添加一些标志，其实这个addFlags()不光可以用来设置Activity的启动模式，还能做很多事情，它的作用是给Intent添加一些附加属性。具体的可以参见Android api哈~<br>　　<br>那我们想设置Activity的启动模式应该给addFlags()方法设置哪些参数呢？来，接着往下看：</p>
<ul>
<li><strong>FLAG_ACTIVITY_NEW_TASK</strong><ul>
<li>与”singleTask”启动模式的作用一样。</li>
</ul>
</li>
<li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><ul>
<li>与”singleTop”启动模式的作用一样。</li>
</ul>
</li>
<li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><ul>
<li>这个标识的意思比较特殊。它不对应于我们上面所说的启动模式中的任何一种，我们来看一下android api中对这个标识的说明：</li>
</ul>
</li>
</ul>
<blockquote>
<p>如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过onNewIntent()<br>将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。</p>
</blockquote>
<p>大家可能会发现，通过addFlags()的方式来设置启动模式有局限性，只能显示的设置“singleTask”和“singleTop”两种启动模式，而并没有对应“standard”和“singleInstance”启动模式的标识。是的，android api文档中确实只只有以上三种标识用来设置启动模式，而且第三种“*<em>FLAG_ACTIVITY_CLEAR_TOP<br>*</em>”还不对应任何一种启动模式，难道可以算作第5种启动模式？遗憾的是，我现在也不清楚是怎么回事。<br>　　<br>但是实际开发中，我们一般都是在AndroidMenifest.xml文件中去设置Activity的启动模式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">zhangyong</p>
              <p class="site-description motion-element" itemprop="description">欢迎来到张永的个人博客，一个关注Android,H5前端,java后端技术分享，爱分享网络资源，分享学到的知识，分享生活的乐趣的网站。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangyong</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
