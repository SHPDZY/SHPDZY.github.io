<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张永的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://9aiplay.com/"/>
  <updated>2019-09-19T08:58:38.132Z</updated>
  <id>http://9aiplay.com/</id>
  
  <author>
    <name>zhangyong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>生活-小家伙越来越可爱了</title>
    <link href="http://9aiplay.com/record/b4de02b9/"/>
    <id>http://9aiplay.com/record/b4de02b9/</id>
    <published>2019-09-19T08:02:23.000Z</published>
    <updated>2019-09-19T08:58:38.132Z</updated>
    
    <content type="html"><![CDATA[<video id="video" controls preload="none" poster="https://9aiplay.com/images/5.jpg">      <source id="mp4" src="https://9aiplay.com/video/5.mp4" type="video/mp4">      </video>]]></content>
    
    <summary type="html">
    
      
      
        &lt;video id=&quot;video&quot; controls preload=&quot;none&quot; poster=&quot;https://9aiplay.com/images/5.jpg&quot;&gt;
      &lt;source id=&quot;mp4&quot; src=&quot;https://9aiplay.com/video/5
      
    
    </summary>
    
    
      <category term="生活" scheme="http://9aiplay.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="http://9aiplay.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Handler都没搞定，拿什么去跳槽！</title>
    <link href="http://9aiplay.com/record/40253/"/>
    <id>http://9aiplay.com/record/40253/</id>
    <published>2019-08-27T04:14:29.000Z</published>
    <updated>2019-09-16T03:12:13.203Z</updated>
    
    <content type="html"><![CDATA[<p>做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。</p><p>Handler应用之广泛，可以说只要有异步线程与主线程通信的地方就一定会有 Handler。</p><p>所以搞懂 Handler 对理解Android非常有必要。</p><p>那么，Handler 的通信机制的背后的原理是什么？</p><p>本文带你揭晓。</p><p>注意：本文所展示的系统源码基于 Android-27 ，并有所删减。</p><h3 id="1-重识-Handler"><a href="#1-重识-Handler" class="headerlink" title="1. 重识 Handler"></a>1. 重识 Handler</h3><p>我们可以使用 Handler 发送并处理与一个线程关联的 Message 和 Runnable 。（注意：Runnable 会被封装进一个 Message，所以它本质上还是一个 Message ）</p><p>每个 Handler 都会跟一个线程绑定，并与该线程的 MessageQueue 关联在一起，从而实现消息的管理以及线程间通信。</p><pre><code>android.os.Handler handler = new Handler(){  @Override  public void handleMessage(final Message msg) {    //这里接受并处理消息  }};//发送消息handler.sendMessage(message);handler.post(runnable);</code></pre><p>实例化一个 Handler 重写 handleMessage 方法 ，然后在需要的时候调用它的 send 以及 post 系列方法就可以了，非常简单易用，并且支持延时消息。（更多方法可查询 API 文档）</p><p>但是奇怪，我们并没有看到任何 MessageQueue 的身影，也没看到它与线程绑定的逻辑，这是怎么回事？</p><h3 id="2-Handler-原理解析"><a href="#2-Handler-原理解析" class="headerlink" title="2. Handler 原理解析"></a>2. Handler 原理解析</h3><p>相信大家早就听说过了 Looper 以及 MessageQueue 了，我就不多绕弯子了。</p><p>不过在开始分析原理之前，先明确我们的问题：</p><p>Handler 是如何与线程关联的？</p><p>Handler 发出去的消息是谁管理的？</p><p>消息又是怎么回到 handleMessage() 方法的？</p><p>线程的切换是怎么回事？</p><h4 id="2-1-Handler-与-Looper-的关联"><a href="#2-1-Handler-与-Looper-的关联" class="headerlink" title="2.1 Handler 与 Looper 的关联"></a>2.1 Handler 与 Looper 的关联</h4><p>实际上我们在实例化 Handler 的时候 Handler 会去检查当前线程的 Looper 是否存在，如果不存在则会报异常，也就是说在创建 Handler 之前一定需要先创建 Looper 。</p><p>代码如下：</p><pre><code> public Handler(Callback callback, boolean async) {         //检查当前的线程是否有 Looper         mLooper = Looper.myLooper();         if (mLooper == null) {             throw new RuntimeException(                &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);         }         //Looper 持有一个 MessageQueue         mQueue = mLooper.mQueue;}</code></pre><p>这个异常相信很多同学遇到过，而我们平时直接使用感受不到这个异常是因为主线程已经为我们创建好了 Looper，先记住，后面会讲。（见【3.2】）</p><p>一个完整的 Handler 使用例子其实是这样的：</p><pre><code> class LooperThread extends Thread {     public Handler mHandler;     public void run() {         Looper.prepare();         mHandler = new Handler() {             public void handleMessage(Message msg) {                 // process incoming messages here             }         };        Looper.loop();    }}</code></pre><p>Looper.prepare() :</p><pre><code>//Looperprivate static void prepare(boolean quitAllowed) {  if (sThreadLocal.get() != null) {    throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);  }  sThreadLocal.set(new Looper(quitAllowed));}</code></pre><p>Looper 提供了 Looper.prepare()  方法来创建 Looper ，并且会借助 ThreadLocal 来实现与当前线程的绑定功能。Looper.loop() 则会开始不断尝试从 MessageQueue 中获取 Message , 并分发给对应的 Handler（见【2.3】）。</p><p>也就是说 Handler 跟线程的关联是靠 Looper 来实现的。</p><h4 id="2-2-Message-的存储与管理"><a href="#2-2-Message-的存储与管理" class="headerlink" title="2.2 Message 的存储与管理"></a>2.2 Message 的存储与管理</h4><p>Handler 提供了一些列的方法让我们来发送消息，如 send()系列 post()系列 。</p><p>不过不管我们调用什么方法，最终都会走到 Message.enqueueMessage(Message,long) 方法。</p><p>以 sendEmptyMessage(int)  方法为例：</p><pre><code>//HandlersendEmptyMessage(int)  -&gt; sendEmptyMessageDelayed(int,int)    -&gt; sendMessageAtTime(Message,long)      -&gt; enqueueMessage(MessageQueue,Message,long)              -&gt; queue.enqueueMessage(Message, long);</code></pre><p>到了这里，消息的管理者 MessageQueue 也就露出了水面。<br>MessageQueue 顾明思议，就是个队列，负责消息的入队出队。</p><h4 id="2-3-Message-的分发与处理"><a href="#2-3-Message-的分发与处理" class="headerlink" title="2.3 Message 的分发与处理"></a>2.3 Message 的分发与处理</h4><p>了解清楚 Message 的发送与存储管理后，就该揭开分发与处理的面纱了。</p><p>前面说到了 Looper.loop()  负责对消息的分发，本章节进行分析。</p><p>先来看看所涉及到的方法：</p><pre><code>//Looperpublic static void loop() {    final Looper me = myLooper();    if (me == null) {        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);    }    final MessageQueue queue = me.mQueue;    //...    for (;;) {       // 不断从 MessageQueue 获取 消息        Message msg = queue.next(); // might block        //退出 Looper         if (msg == null) {            // No message indicates that the message queue is quitting.            return;        }        //...        try {            msg.target.dispatchMessage(msg);            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();        } finally {            //...        }        //...                //回收 message, 见【3.5】        msg.recycleUnchecked();    }}</code></pre><p>loop() 里调用了 MessageQueue.next() :</p><pre><code>//MessageQueueMessage next() {    //...    for (;;) {        //...        nativePollOnce(ptr, nextPollTimeoutMillis);        synchronized (this) {            // Try to retrieve the next message.  Return if found.            final long now = SystemClock.uptimeMillis();            Message prevMsg = null;            Message msg = mMessages;            //...            if (msg != null) {                if (now &lt; msg.when) {                    // Next message is not ready.  Set a timeout to wake up when it is ready.                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);                } else {                    // Got a message.                    mBlocked = false;                    if (prevMsg != null) {                        prevMsg.next = msg.next;                    } else {                        mMessages = msg.next;                    }                    msg.next = null;                    return msg;                }            } else {                // No more messages.                nextPollTimeoutMillis = -1;            }            // Process the quit message now that all pending messages have been handled.            if (mQuitting) {                dispose();                return null;            }        }        // Run the idle handlers. 关于 IdleHandler 自行了解        //...    }}</code></pre><p>还调用了 msg.target.dispatchMessage(msg) ，msg.target 就是发送该消息的 Handler，这样就回调到了 Handler 那边去了:</p><pre><code> //Handler public void dispatchMessage(Message msg) {   //msg.callback 是 Runnable ，如果是 post方法则会走这个 if   if (msg.callback != null) {     handleCallback(msg);   } else {     //callback 见【3.4】     if (mCallback != null) {       if (mCallback.handleMessage(msg)) {        return;      }    }    //回调到 Handler 的 handleMessage 方法    handleMessage(msg);  }}</code></pre><p>注意：dispatchMessage() 方法针对 Runnable 的方法做了特殊处理，如果是 ，则会直接执行 Runnable.run() 。</p><p>分析：Looper.loop() 是个死循环，会不断调用 MessageQueue.next() 获取 Message ，并调用 msg.target.dispatchMessage(msg) 回到了 Handler 来分发消息，以此来完成消息的回调。</p><p>注意：loop()方法并不会卡死主线程，见【6】。</p><p>那么线程的切换又是怎么回事呢？<br>很多人搞不懂这个原理，但是其实非常简单，我们将所涉及的方法调用栈画出来，如下：</p><pre><code>Thread.foo(){    Looper.loop()     -&gt; MessageQueue.next()       -&gt; Message.target.dispatchMessage()        -&gt; Handler.handleMessage()}</code></pre><p>显而易见，Handler.handleMessage() 所在的线程最终由调用 Looper.loop() 的线程所决定。</p><p>平时我们用的时候从异步线程发送消息到 Handler，这个 Handler 的 handleMessage() 方法是在主线程调用的，所以消息就从异步线程切换到了主线程。</p><p><img src="../Handler%E9%83%BD%E6%B2%A1%E6%90%9E%E5%AE%9A%EF%BC%8C%E6%8B%BF%E4%BB%80%E4%B9%88%E5%8E%BB%E8%B7%B3%E6%A7%BD%EF%BC%81/1.png" alt><br><img src="../Handler%E9%83%BD%E6%B2%A1%E6%90%9E%E5%AE%9A%EF%BC%8C%E6%8B%BF%E4%BB%80%E4%B9%88%E5%8E%BB%E8%B7%B3%E6%A7%BD%EF%BC%81/2.png" alt></p><h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><p>Handler 的背后有着 Looper 以及 MessageQueue 的协助，三者通力合作，分工明确。</p><p>尝试小结一下它们的职责，如下：</p><ul><li><p>Looper ：负责关联线程以及消息的分发，会与创建它的线程绑定，并负责在该线程下从 MessageQueue 获取 Message，分发给 Handler ；</p></li><li><p>MessageQueue ：是个队列，负责消息的存储与管理，负责管理由 Handler 发送过来的 Message ；</p></li><li><p>Handler : 负责发送并处理消息，面向开发者，提供 API，并隐藏背后实现的细节。</p></li></ul><p>对【2】章节提出的问题用一句话总结：</p><p>Handler 发送的消息由 MessageQueue 存储管理，并由 Loopler 负责回调消息到 handleMessage()。</p><p>线程的转换由 Looper 完成，handleMessage() 所在线程由 Looper.loop() 调用者所在线程决定。</p><h3 id="3-Handler-的延伸"><a href="#3-Handler-的延伸" class="headerlink" title="3. Handler 的延伸"></a>3. Handler 的延伸</h3><p>Handler 虽然简单易用，但是要用好它还是需要注意一点，另外 Handler相关 还有些鲜为人知的知识技巧，比如 IdleHandler。</p><p>由于 Handler 的特性，它在 Android 里的应用非常广泛，比如： AsyncTask、HandlerThread、Messenger、IdleHandler 和 IntentService 等等。</p><p>这些我会讲解一些，我没讲到的可以自行搜索相关内容进行了解。</p><h4 id="3-1-Handler-引起的内存泄露原因以及最佳解决方案"><a href="#3-1-Handler-引起的内存泄露原因以及最佳解决方案" class="headerlink" title="3.1 Handler 引起的内存泄露原因以及最佳解决方案"></a>3.1 Handler 引起的内存泄露原因以及最佳解决方案</h4><p>Handler 允许我们发送延时消息，如果在延时期间用户关闭了 Activity，那么该 Activity 会泄露。</p><p>这个泄露是因为 Message 会持有 Handler，而又因为 Java 的特性，内部类会持有外部类，使得 Activity 会被 Handler 持有，这样最终就导致 Activity 泄露。</p><p>解决该问题的最有效的方法是：将 Handler 定义成静态的内部类，在内部持有 Activity 的弱引用，并及时移除所有消息。</p><p>示例代码如下：</p><pre><code> private static class SafeHandler extends Handler {     private WeakReference&lt;HandlerActivity&gt; ref;     public SafeHandler(HandlerActivity activity) {         this.ref = new WeakReference(activity);     }     @Override    public void handleMessage(final Message msg) {        HandlerActivity activity = ref.get();        if (activity != null) {            activity.handleMessage(msg);        }    }}</code></pre><p>并且再在 Activity.onDestroy() 前移除消息，加一层保障：</p><pre><code>@Overrideprotected void onDestroy() {  safeHandler.removeCallbacksAndMessages(null);  super.onDestroy();}</code></pre><p>这样双重保障，就能完全避免内存泄露了。</p><p>注意：单纯的在 onDestroy 移除消息并不保险，因为 onDestroy 并不一定执行。</p><h4 id="3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？"><a href="#3-2-为什么我们能在主线程直接使用-Handler，而不需要创建-Looper-？" class="headerlink" title="3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？"></a>3.2 为什么我们能在主线程直接使用 Handler，而不需要创建 Looper ？</h4><p>前面我们提到了每个Handler 的线程都有一个 Looper ，主线程当然也不例外，但是我们不曾准备过主线程的 Looper 而可以直接使用，这是为何？</p><p>注意：通常我们认为 ActivityThread 就是主线程。事实上它并不是一个线程，而是主线程操作的管理者，所以吧，我觉得把 ActivityThread 认为就是主线程无可厚非，另外主线程也可以说成 UI 线程。</p><p>在 ActivityThread.main() 方法中有如下代码：</p><pre><code> //android.app.ActivityThread public static void main(String[] args) {   //...   Looper.prepareMainLooper();   ActivityThread thread = new ActivityThread();   thread.attach(false);   if (sMainThreadHandler == null) {    sMainThreadHandler = thread.getHandler();  }  //...  Looper.loop();  throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>Looper.prepareMainLooper(); 代码如下：</p><pre><code>/** * Initialize the current thread as a looper, marking it as an * application&apos;s main looper. The main looper for your application * is created by the Android environment, so you should never need * to call this function yourself.  See also: {@link #prepare()} */public static void prepareMainLooper() {    prepare(false);    synchronized (Looper.class) {        if (sMainLooper != null) {            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);        }        sMainLooper = myLooper();    }}</code></pre><p>可以看到在 ActivityThread 里 调用了 Looper.prepareMainLooper() 方法创建了 主线程的 Looper ,并且调用了 loop() 方法，所以我们就可以直接使用 Handler 了。</p><p>注意：Looper.loop() 是个死循环，后面的代码正常情况不会执行。</p><h4 id="3-3-主线程的-Looper-不允许退出"><a href="#3-3-主线程的-Looper-不允许退出" class="headerlink" title="3.3 主线程的 Looper 不允许退出"></a>3.3 主线程的 Looper 不允许退出</h4><p>如果你尝试退出 Looper ，你会得到以下错误信息：</p><pre><code>Caused by: java.lang.IllegalStateException: Main thread not allowed to quit.  at android.os.MessageQueue.quit(MessageQueue.java:415)  at android.os.Looper.quit(Looper.java:240)</code></pre><p>why? 其实原因很简单，主线程不允许退出，退出就意味 APP 要挂。</p><h4 id="3-4-Handler-里藏着的-Callback-能干什么？"><a href="#3-4-Handler-里藏着的-Callback-能干什么？" class="headerlink" title="3.4 Handler 里藏着的 Callback 能干什么？"></a>3.4 Handler 里藏着的 Callback 能干什么？</h4><p>在 Handler 的构造方法中有几个 要求传入 Callback ，那它是什么，又能做什么呢？</p><p>来看看 Handler.dispatchMessage(msg)  方法：</p><pre><code>public void dispatchMessage(Message msg) {  //这里的 callback 是 Runnable  if (msg.callback != null) {    handleCallback(msg);  } else {    //如果 callback 处理了该 msg 并且返回 true， 就不会再回调 handleMessage    if (mCallback != null) {      if (mCallback.handleMessage(msg)) {        return;      }    }    handleMessage(msg);  }}</code></pre><p>可以看到 Handler.Callback 有优先处理消息的权利 ，当一条消息被 Callback 处理并拦截（返回 true），那么 Handler 的 handleMessage(msg) 方法就不会被调用了；如果 Callback 处理了消息，但是并没有拦截，那么就意味着一个消息可以同时被 Callback 以及 Handler 处理。</p><p>这个就很有意思了，这有什么作用呢？</p><p>我们可以利用 Callback 这个拦截机制来拦截 Handler 的消息！</p><p>场景：Hook ActivityThread.mH ， 在 ActivityThread 中有个成员变量 mH ，它是个 Handler，又是个极其重要的类，几乎所有的插件化框架都使用了这个方法。</p><h4 id="3-5-创建-Message-实例的最佳方式"><a href="#3-5-创建-Message-实例的最佳方式" class="headerlink" title="3.5 创建 Message 实例的最佳方式"></a>3.5 创建 Message 实例的最佳方式</h4><p>由于 Handler 极为常用，所以为了节省开销，Android 给 Message 设计了回收机制，所以我们在使用的时候尽量复用 Message ，减少内存消耗。</p><p>方法有二：</p><p>通过 Message 的静态方法 Message.obtain();   获取；</p><p>通过 Handler 的公有方法 handler.obtainMessage(); 。</p><h4 id="3-6-子线程里弹-Toast-的正确姿势"><a href="#3-6-子线程里弹-Toast-的正确姿势" class="headerlink" title="3.6 子线程里弹 Toast 的正确姿势"></a>3.6 子线程里弹 Toast 的正确姿势</h4><p>当我们尝试在子线程里直接去弹 Toast 的时候，会 crash ：</p><pre><code>java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare() </code></pre><p>本质上是因为 Toast 的实现依赖于 Handler，按子线程使用 Handler 的要求修改即可（见【2.1】），同理的还有 Dialog。</p><p>正确示例代码如下：</p><pre><code>new Thread(new Runnable() {  @Override  public void run() {    Looper.prepare();    Toast.makeText(HandlerActivity.this, &quot;不会崩溃啦！&quot;, Toast.LENGTH_SHORT).show();    Looper.loop();  }});</code></pre><h4 id="3-7-妙用-Looper-机制"><a href="#3-7-妙用-Looper-机制" class="headerlink" title="3.7 妙用 Looper 机制"></a>3.7 妙用 Looper 机制</h4><p>我们可以利用 Looper 的机制来帮助我们做一些事情：</p><p>将 Runnable post 到主线程执行；</p><p>利用 Looper 判断当前线程是否是主线程。</p><p>完整示例代码如下：</p><pre><code> public final class MainThread {     private MainThread() {     }     private static final Handler HANDLER = new Handler(Looper.getMainLooper());     public static void run(@NonNull Runnable runnable) {         if (isMainThread()) {            runnable.run();        }else{            HANDLER.post(runnable);        }    }    public static boolean isMainThread() {        return Looper.myLooper() == Looper.getMainLooper();    }}</code></pre><p>能够省去不少样板代码。</p><h3 id="4-知识点汇总"><a href="#4-知识点汇总" class="headerlink" title="4. 知识点汇总"></a>4. 知识点汇总</h3><p>由前文可得出一些知识点，汇总一下，方便记忆。</p><p>Handler 的背后有 Looper、MessageQueue 支撑，Looper 负责消息分发，MessageQueue 负责消息管理；</p><p>在创建 Handler 之前一定需要先创建 Looper；</p><p>Looper 有退出的功能，但是主线程的 Looper 不允许退出；</p><p>异步线程的 Looper 需要自己调用 Looper.myLooper().quit();  退出；</p><p>Runnable 被封装进了 Message，可以说是一个特殊的 Message；</p><p>Handler.handleMessage() 所在的线程是 Looper.loop() 方法被调用的线程，也可以说成 Looper 所在的线程，并不是创建 Handler 的线程；</p><p>使用内部类的方式使用 Handler 可能会导致内存泄露，即便在 Activity.onDestroy 里移除延时消息，必须要写成静态内部类；</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p>Handler 简单易用的背后藏着工程师大量的智慧，要努力向他们学习。</p><p>看完并理解本文可以说你对 Handler 有了一个非常深入且全面的了解，应对面试肯定是绰绰有余了。</p><h3 id="6-参考和推荐"><a href="#6-参考和推荐" class="headerlink" title="6. 参考和推荐"></a>6. 参考和推荐</h3><p><a href="https://developer.android.com/reference/android/os/Handler" title="Handler" target="_blank" rel="noopener">https://developer.android.com/reference/android/os/Handler</a><br><a href="https://stackoverflow.com/questions/12877944/what-is-the-relationship-between-looper-handler-and-messagequeue-in-android" title="what-is-the-relationship-between-looper-handler-and-messagequeue-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/12877944/what-is-the-relationship-between-looper-handler-and-messagequeue-in-android</a><br><a href="http://gityuan.com/2015/12/26/handler-message-framework/" title="Android消息机制1-Handler（Java 层" target="_blank" rel="noopener">http://gityuan.com/2015/12/26/handler-message-framework/</a>）<br><a href="https://www.zhihu.com/question/34652589/answer/90344494" title="Android中为什么主线程不会卡死" target="_blank" rel="noopener">https://www.zhihu.com/question/34652589/answer/90344494</a></p><hr><p>本文原作者： 程序亦非猿<br>本文原链接： <a href="http://yifeiyuan.me/blog/f77487d3.html" target="_blank" rel="noopener">http://yifeiyuan.me/blog/f77487d3.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做 Android 开发肯定离不开跟 Handler 打交道，它通常被我们用来做主线程与子线程之间的通信工具，而 Handler 作为 Android 中消息机制的重要一员也确实给我们的开发带来了极大的便利。&lt;/p&gt;
&lt;p&gt;Handler应用之广泛，可以说只要有异步线程与主
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="转载" scheme="http://9aiplay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Handler" scheme="http://9aiplay.com/tags/Handler/"/>
    
  </entry>
  
  <entry>
    <title>Android大厂面试题锦集</title>
    <link href="http://9aiplay.com/record/43075/"/>
    <id>http://9aiplay.com/record/43075/</id>
    <published>2019-06-15T06:34:56.000Z</published>
    <updated>2019-09-16T03:12:13.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-android事件分发机制，请详细说下整个流程"><a href="#1-android事件分发机制，请详细说下整个流程" class="headerlink" title="1.android事件分发机制，请详细说下整个流程"></a>1.android事件分发机制，请详细说下整个流程</h3><p><img src="../Android%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98%E9%94%A6%E9%9B%86/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.png" alt></p><h3 id="2-android-view绘制机制和加载过程，请详细说下整个流程"><a href="#2-android-view绘制机制和加载过程，请详细说下整个流程" class="headerlink" title="2.android view绘制机制和加载过程，请详细说下整个流程"></a>2.android view绘制机制和加载过程，请详细说下整个流程</h3><ol><li><p>ViewRootImpl会调用performTraversals(),其内部会调用performMeasure()、performLayout、performDraw()。</p></li><li><p>performMeasure()会调用最外层的ViewGroup的measure()–&gt;onMeasure(),ViewGroup的onMeasure()是抽象方法，但其提供了measureChildren()，这之中会遍历子View然后循环调用measureChild()这之中会用getChildMeasureSpec()+父View的MeasureSpec+子View的LayoutParam一起获取本View的MeasureSpec，然后调用子View的measure()到View的onMeasure()–&gt;setMeasureDimension(getDefaultSize(),getDefaultSize()),getDefaultSize()默认返回measureSpec的测量数值，所以继承View进行自定义的wrap_content需要重写。</p></li><li><p>performLayout()会调用最外层的ViewGroup的layout(l,t,r,b),本View在其中使用setFrame()设置本View的四个顶点位置。在onLayout(抽象方法)中确定子View的位置，如LinearLayout会遍历子View，循环调用setChildFrame()–&gt;子View.layout()。</p></li><li><p>performDraw()会调用最外层ViewGroup的draw():其中会先后调用background.draw()(绘制背景)、onDraw()(绘制自己)、dispatchDraw()(绘制子View)、onDrawScrollBars()(绘制装饰)。</p></li><li><p>MeasureSpec由2位SpecMode(UNSPECIFIED、EXACTLY(对应精确值和match_parent)、AT_MOST(对应warp_content))和30位SpecSize组成一个int,DecorView的MeasureSpec由窗口大小和其LayoutParams决定，其他View由父View的MeasureSpec和本View的LayoutParams决定。ViewGroup中有getChildMeasureSpec()来获取子View的MeasureSpec。</p></li><li><p>三种方式获取measure()后的宽高：</p><ul><li>Activity#onWindowFocusChange()中调用获取</li><li>view.post(Runnable)将获取的代码投递到消息队列的尾部。</li><li>ViewTreeObservable.</li></ul></li></ol><h3 id="3-android四大组件的加载过程，请详细介绍下"><a href="#3-android四大组件的加载过程，请详细介绍下" class="headerlink" title="3.android四大组件的加载过程，请详细介绍下"></a>3.android四大组件的加载过程，请详细介绍下</h3><ol><li><a href="https://www.jianshu.com/p/f499afd8d0ab" title="android四大组件的加载过程" target="_blank" rel="noopener">https://www.jianshu.com/p/f499afd8d0ab</a>:这是我总结的一篇博客</li></ol><h3 id="4-Activity的启动模式"><a href="#4-Activity的启动模式" class="headerlink" title="4.Activity的启动模式"></a>4.Activity的启动模式</h3><ol><li>standard:默认标准模式，每启动一个都会创建一个实例，</li><li>singleTop：栈顶复用，如果在栈顶就调用onNewIntent复用，从onResume()开始</li><li>singleTask：栈内复用，本栈内只要用该类型Activity就会将其顶部的activity出栈</li><li>singleInstance：单例模式，除了3中特性，系统会单独给该Activity创建一个栈，</li></ol><h3 id="5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的"><a href="#5-A、B、C、D分别是四种Activity的启动模式，那么A-gt-B-gt-C-gt-D-gt-A-gt-B-gt-C-gt-D分别启动，最后的activity栈是怎么样的" class="headerlink" title="5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的"></a>5.A、B、C、D分别是四种Activity的启动模式，那么A-&gt;B-&gt;C-&gt;D-&gt;A-&gt;B-&gt;C-&gt;D分别启动，最后的activity栈是怎么样的</h3><ol><li>这个题目需要深入了解activity的启动模式</li><li>最后的答案是：两个栈，前台栈是只有D，后台栈从底至上是A、B、C</li></ol><h3 id="6-Activity缓存方法"><a href="#6-Activity缓存方法" class="headerlink" title="6.Activity缓存方法"></a>6.Activity缓存方法</h3><ol><li>配置改变导致Activity被杀死，横屏变竖屏：在onStop之前会调用onSaveInstanceState()保存数据在重建Activity之后，会在onStart()之后调用onRestoreInstanceState(),并把保存下来的Bundle传给onCreate()和它会默认重建Activity当前的视图，我们可以在onCreate()中，回复自己的数据。</li><li>内存不足杀掉Activity，优先级分别是：前台可见，可见非前台，后台。</li></ol><h3 id="7-Service的生命周期，两种启动方法，有什么区别"><a href="#7-Service的生命周期，两种启动方法，有什么区别" class="headerlink" title="7.Service的生命周期，两种启动方法，有什么区别"></a>7.Service的生命周期，两种启动方法，有什么区别</h3><ol><li><p>context.startService() -&gt;onCreate()- &gt;onStart()-&gt;Service running–&gt;(如果调用context.stopService() )-&gt;onDestroy() -&gt;Service shut down</p><ul><li>如果Service还没有运行，则调用onCreate()然后调用onStart()；</li><li>如果Service已经运行，则只调用onStart()，所以一个Service的onStart方法可能会重复调用多次。</li><li>调用stopService的时候直接onDestroy，</li><li>如果是调用者自己直接退出而没有调用stopService的话，Service会一直在后台运行。该Service的调用者再启动起来后可以通过stopService关闭Service。</li></ul></li></ol><ol start="2"><li><p>context.bindService()-&gt;onCreate()-&gt;onBind()-&gt;Service running–&gt;onUnbind() -&gt; onDestroy() -&gt;Service stop</p><ul><li>onBind将返回给客户端一个IBind接口实例，IBind允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。</li><li>这个时候会把调用者和Service绑定在一起，Context退出了,Service就会调用onUnbind-&gt;onDestroy相应退出。</li><li>所以调用bindService的生命周期为：onCreate –&gt; onBind(只一次，不可多次绑定) –&gt; onUnbind –&gt; onDestory。</li></ul></li></ol><h3 id="8-怎么保证service不被杀死"><a href="#8-怎么保证service不被杀死" class="headerlink" title="8.怎么保证service不被杀死"></a>8.怎么保证service不被杀死</h3><ol><li>提升service优先级</li><li>提升service进程优先级</li><li>onDestroy方法里重启service</li></ol><h3 id="9-静态的Broadcast-和动态的有什么区别"><a href="#9-静态的Broadcast-和动态的有什么区别" class="headerlink" title="9.静态的Broadcast 和动态的有什么区别"></a>9.静态的Broadcast 和动态的有什么区别</h3><ol><li>动态的比静态的安全</li><li>静态在app启动的时候就初始化了 动态使用代码初始化</li><li>静态需要配置 动态不需要</li><li>生存期，静态广播的生存期可以比动态广播的长很多</li><li>优先级动态广播的优先级比静态广播高</li></ol><h3 id="10-Intent可以传递哪些数据类型"><a href="#10-Intent可以传递哪些数据类型" class="headerlink" title="10.Intent可以传递哪些数据类型"></a>10.Intent可以传递哪些数据类型</h3><ol><li>Serializable</li><li>charsequence: 主要用来传递String，char等</li><li>parcelable</li><li>Bundle</li></ol><h3 id="11-Json有什么优劣势、解析的原理"><a href="#11-Json有什么优劣势、解析的原理" class="headerlink" title="11.Json有什么优劣势、解析的原理"></a>11.Json有什么优劣势、解析的原理</h3><ol><li>JSON的速度要远远快于XML</li><li>JSON相对于XML来讲，数据的体积小</li><li>JSON对数据的描述性比XML较差</li><li>解析的基本原理是：词法分析</li></ol><h3 id="12-一个语言的编译过程"><a href="#12-一个语言的编译过程" class="headerlink" title="12.一个语言的编译过程"></a>12.一个语言的编译过程</h3><ol><li>词法分析：将一串文本按规则分割成最小的结构，关键字、标识符、运算符、界符和常量等。一般实现方法是自动机和正则表达式</li><li>语法分析：将一系列单词组合成语法树。一般实现方法有自顶向下和自底向上</li><li>语义分析：对结构上正确的源程序进行上下文有关性质的审查</li><li>目标代码生成</li><li>代码优化：优化生成的目标代码，</li></ol><h3 id="13-动画有哪几类，各有什么特点"><a href="#13-动画有哪几类，各有什么特点" class="headerlink" title="13.动画有哪几类，各有什么特点"></a>13.动画有哪几类，各有什么特点</h3><ol><li><p>动画的基本原理：其实就是利用插值器和估值器，来计算出各个时刻View的属性，然后通过改变View的属性来，实现View的动画效果。</p></li><li><p>View动画:只是影像变化，view的实际位置还在原来的地方。</p></li><li><p>帧动画是在xml中定义好一系列图片之后，使用AnimationDrawable来播放的动画。</p></li><li><p>View的属性动画：</p><ul><li>插值器：作用是根据时间的流逝的百分比来计算属性改变的百分比</li><li>估值器：在1的基础上由这个东西来计算出属性到底变化了多少数值的类</li></ul></li></ol><h3 id="14-Handler、Looper消息队列模型，各部分的作用"><a href="#14-Handler、Looper消息队列模型，各部分的作用" class="headerlink" title="14.Handler、Looper消息队列模型，各部分的作用"></a>14.Handler、Looper消息队列模型，各部分的作用</h3><ol><li>MessageQueue：读取会自动删除消息，单链表维护，在插入和删除上有优势。在其next()中会无限循环，不断判断是否有消息，有就返回这条消息并移除。</li><li>Looper：Looper创建的时候会创建一个MessageQueue，调用loop()方法的时候消息循环开始，loop()也是一个死循环，会不断调用messageQueue的next()，当有消息就处理，否则阻塞在messageQueue的next()中。当Looper的quit()被调用的时候会调用messageQueue的quit(),此时next()会返回null，然后loop()方法也跟着退出。</li><li>Handler：在主线程构造一个Handler，然后在其他线程调用sendMessage(),此时主线程的MessageQueue中会插入一条message，然后被Looper使用。</li><li>系统的主线程在ActivityThread的main()为入口开启主线程，其中定义了内部类Activity.H定义了一系列消息类型，包含四大组件的启动停止。</li><li>MessageQueue和Looper是一对一关系，Handler和Looper是多对一</li></ol><h3 id="15-怎样退出终止App"><a href="#15-怎样退出终止App" class="headerlink" title="15.怎样退出终止App"></a>15.怎样退出终止App</h3><ol><li>自己设置一个Activity的栈，然后一个个finish()</li></ol><h3 id="16-Android-IPC-Binder原理"><a href="#16-Android-IPC-Binder原理" class="headerlink" title="16.Android IPC:Binder原理"></a>16.Android IPC:Binder原理</h3><ol><li><p>在Activity和Service进行通讯的时候，用到了Binder。</p><ul><li>当属于同个进程我们可以继承Binder然后在Activity中对Service进行操作</li><li>当不属于同个进程，那么要用到AIDL让系统给我们创建一个Binder，然后在Activity中对远端的Service进行操作。</li></ul></li></ol><ol start="2"><li><p>系统给我们生成的Binder：</p><ul><li>Stub类中有:接口方法的id，有该Binder的标识，有asInterface(IBinder)(让我们在Activity中获取实现了Binder的接口，接口的实现在Service里，同进程时候返回Stub否则返回Proxy)，有onTransact()这个方法是在不同进程的时候让Proxy在Activity进行远端调用实现Activity操作Service</li><li>Proxy类是代理，在Activity端，其中有:IBinder mRemote(这就是远端的Binder)，两个接口的实现方法不过是代理最终还是要在远端的onTransact()中进行实际操作。</li></ul></li></ol><pre><code>- 哪一端的Binder是副本，该端就可以被另一端进行操作，因为Binder本体在定义的时候可以操作本端的东西。所以可以在Activity端传入本端的Binder，让Service端对其进行操作称为Listener，可以用RemoteCallbackList这个容器来装Listener，防止Listener因为经历过序列化而产生的问题。- 当Activity端向远端进行调用的时候，当前线程会挂起，当方法处理完毕才会唤醒。- 如果一个AIDL就用一个Service太奢侈，所以可以使用Binder池的方式，建立一个AIDL其中的方法是返回IBinder，然后根据方法中传入的参数返回具体的AIDL。- IPC的方式有：Bundle（在Intent启动的时候传入，不过是一次性的），文件共享(对于SharedPreference是特例，因为其在内存中会有缓存)，使用Messenger(其底层用的也是AIDL，同理要操作哪端，就在哪端定义Messenger)，AIDL，ContentProvider(在本进程中继承实现一个ContentProvider，在增删改查方法中调用本进程的SQLite，在其他进程中查询)，Socket</code></pre><h3 id="17-描述一次跨进程通讯"><a href="#17-描述一次跨进程通讯" class="headerlink" title="17.描述一次跨进程通讯"></a>17.描述一次跨进程通讯</h3><ol><li>client、proxy、serviceManager、BinderDriver、impl、service</li><li>client发起一个请求service信息的Binder请求到BinderDriver中，serviceManager发现BinderDiriver中有自己的请求 然后将clinet请求的service的数据返回给client这样完成了一次Binder通讯</li><li>clinet获取的service信息就是该service的proxy，此时调用proxy的方法，proxy将请求发送到BinderDriver中，此时service的 Binder线程池循环发现有自己的请求，然后用impl就处理这个请求最后返回，这样完成了第二次Binder通讯</li><li>中间client可挂起，也可以不挂起，有一个关键字oneway可以解决这个</li></ol><h3 id="18-android重要术语解释"><a href="#18-android重要术语解释" class="headerlink" title="18.android重要术语解释"></a>18.android重要术语解释</h3><ol><li>ActivityManagerServices，简称AMS，服务端对象，负责系统中所有Activity的生命周期</li><li>ActivityThread，App的真正入口。当开启App之后，会调用main()开始运行，开启消息循环队列，这就是传说中的UI线程或者叫主线程。与ActivityManagerServices配合，一起完成Activity的管理工作</li><li>ApplicationThread，用来实现ActivityManagerService与ActivityThread之间的交互。在ActivityManagerService需要管理相关Application中的Activity的生命周期时，通过ApplicationThread的代理对象与ActivityThread通讯。</li><li>ApplicationThreadProxy，是ApplicationThread在服务器端的代理，负责和客户端的ApplicationThread通讯。AMS就是通过该代理与ActivityThread进行通信的。</li><li>Instrumentation，每一个应用程序只有一个Instrumentation对象，每个Activity内都有一个对该对象的引用。Instrumentation可以理解为应用进程的管家，ActivityThread要创建或暂停某个Activity时，都需要通过Instrumentation来进行具体的操作。</li><li>ActivityStack，Activity在AMS的栈管理，用来记录已经启动的Activity的先后关系，状态信息等。通过ActivityStack决定是否需要启动新的进程。</li><li>ActivityRecord，ActivityStack的管理对象，每个Activity在AMS对应一个ActivityRecord，来记录Activity的状态以及其他的管理信息。其实就是服务器端的Activity对象的映像。</li><li>TaskRecord，AMS抽象出来的一个“任务”的概念，是记录ActivityRecord的栈，一个“Task”包含若干个ActivityRecord。AMS用TaskRecord确保Activity启动和退出的顺序。如果你清楚Activity的4种launchMode，那么对这个概念应该不陌生。</li></ol><h3 id="19-理解Window和WindowManager"><a href="#19-理解Window和WindowManager" class="headerlink" title="19.理解Window和WindowManager"></a>19.理解Window和WindowManager</h3><ol><li>Window用于显示View和接收各种事件，Window有三种类型：应用Window(每个Activity对应一个Window)、子Window(不能单独存在，附属于特定Window)、系统window(Toast和状态栏)</li><li>Window分层级，应用Window在1-99、子Window在1000-1999、系统Window在2000-2999.WindowManager提供了增删改View三个功能。</li><li>Window是个抽象概念：每一个Window对应着一个View和ViewRootImpl，Window通过ViewRootImpl来和View建立联系，View是Window存在的实体，只能通过WindowManager来访问Window。</li><li>WindowManager的实现是WindowManagerImpl其再委托给WindowManagerGlobal来对Window进行操作，其中有四个List分别储存对应的View、ViewRootImpl、WindowManger.LayoutParams和正在被删除的View</li><li>Window的实体是存在于远端的WindowMangerService中，所以增删改Window在本端是修改上面的几个List然后通过ViewRootImpl重绘View，通过WindowSession(每个应用一个)在远端修改Window。</li><li>Activity创建Window：Activity会在attach()中创建Window并设置其回调(onAttachedToWindow()、dispatchTouchEvent()),Activity的Window是由Policy类创建PhoneWindow实现的。然后通过Activity#setContentView()调用PhoneWindow的setContentView。</li></ol><h3 id="20-Bitmap的处理"><a href="#20-Bitmap的处理" class="headerlink" title="20.Bitmap的处理"></a>20.Bitmap的处理</h3><ol><li><p>当使用ImageView的时候，可能图片的像素大于ImageView，此时就可以通过BitmapFactory.Option来对图片进行压缩，inSampleSize表示缩小2^(inSampleSize-1)倍。</p></li><li><p>BitMap的缓存：</p><ul><li>使用LruCache进行内存缓存。</li><li>使用DiskLruCache进行硬盘缓存。</li></ul></li><li><p>实现一个ImageLoader的流程：同步异步加载、图片压缩、内存硬盘缓存、网络拉取</p><ul><li>同步加载只创建一个线程然后按照顺序进行图片加载</li><li>异步加载使用线程池，让存在的加载任务都处于不同线程</li><li>为了不开启过多的异步任务，只在列表静止的时候开启图片加载</li></ul></li></ol><h3 id="21-如何实现一个网络框架-参考Volley"><a href="#21-如何实现一个网络框架-参考Volley" class="headerlink" title="21.如何实现一个网络框架(参考Volley)"></a>21.如何实现一个网络框架(参考Volley)</h3><ol><li>缓存队列,以url为key缓存内容可以参考Bitmap的处理方式，这里单独开启一个线程。</li><li>网络请求队列，使用线程池进行请求。</li><li>提供各种不同类型的返回值的解析如String，Json，图片等等。</li></ol><p>###22.ClassLoader的基础知识</p><ol><li><p>双亲委托：一个ClassLoader类负责加载这个类所涉及的所有类，在加载的时候会判断该类是否已经被加载过，然后会递归去他父ClassLoader中找。</p></li><li><p>可以动态加载Jar通过URLClassLoader</p></li><li><p>ClassLoader 隔离问题 JVM识别一个类是由：ClassLoader id+PackageName+ClassName。</p></li><li><p>加载不同Jar包中的公共类：</p><ul><li>让父ClassLoader加载公共的Jar，子ClassLoader加载包含公共Jar的Jar，此时子ClassLoader在加载公共Jar的时候会先去父ClassLoader中找。(只适用Java)</li><li>重写加载包含公共Jar的Jar的ClassLoader，在loadClass中找到已经加载过公共Jar的ClassLoader，也就是把父ClassLoader替换掉。(只适用Java)</li><li>在生成包含公共Jar的Jar时候把公共Jar去掉。</li></ul></li></ol><h3 id="23-插件化框架描述：dynamicLoadApk为例子"><a href="#23-插件化框架描述：dynamicLoadApk为例子" class="headerlink" title="23.插件化框架描述：dynamicLoadApk为例子"></a>23.插件化框架描述：dynamicLoadApk为例子</h3><ol><li><p>可以通过DexClassLoader来对apk中的dex包进行加载访问</p></li><li><p>如何加载资源是个很大的问题，因为宿主程序中并没有apk中的资源，所以调用R资源会报错，所以这里使用了Activity中的实现ContextImpl的getAssets()和getResources()再加上反射来实现。</p></li><li><p>由于系统启动Activity有很多初始化动作要做，而我们手动反射很难完成，所以可以采用接口机制，将Activity的大部分生命周期提取成接口，然后通过代理Activity去调用插件Activity的生命周期。同时如果像增加一个新生命周期方法的时候，只需要在接口中和代理中声明一下就行。</p></li><li><p>缺点：</p><ul><li>慎用this，因为在apk中使用this并不代表宿主中的activity，当然如果this只是表示自己的接口还是可以的。除此之外可以使用that代替this。</li><li>不支持Service和静态注册的Broadcast</li><li>不支持LaunchMode和Apk中Activity的隐式调用。</li></ul></li></ol><h3 id="24-热修复：Andfix为例子"><a href="#24-热修复：Andfix为例子" class="headerlink" title="24.热修复：Andfix为例子"></a>24.热修复：Andfix为例子</h3><ol><li>大致原理：apkpatch将两个apk做一次对比，然后找出不同的部分。可以看到生成的apatch了文件，后缀改成zip再解压开，里面有一个dex文件。通过jadx查看一下源码，里面就是被修复的代码所在的类文件,这些更改过的类都加上了一个_CF的后缀，并且变动的方法都被加上了一个叫@MethodReplace的annotation，通过clazz和method指定了需要替换的方法。然后客户端sdk得到补丁文件后就会根据annotation来寻找需要替换的方法。最后由JNI层完成方法的替换。</li><li>无法添加新类和新的字段、补丁文件很容易被反编译、加固平台可能会使热补丁功能失效</li></ol><h3 id="25-线程同步的问题，常用的线程同步"><a href="#25-线程同步的问题，常用的线程同步" class="headerlink" title="25.线程同步的问题，常用的线程同步"></a>25.线程同步的问题，常用的线程同步</h3><ol><li><p>sycn：保证了原子性、可见性、有序性</p></li><li><p>锁：保证了原子性、可见性、有序性</p><ul><li><p>自旋锁:可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环。</p><ul><li>优点:线程被挂起的几率减少，线程执行的连贯性加强。用于对于锁竞争不是很激烈，锁占用时间很短的并发线程。</li><li>缺点:过多浪费CPU时间，有一个线程连续两次试图获得自旋锁引起死锁</li></ul></li></ul></li></ol><pre><code>- 阻塞锁:没得到锁的线程等待或者挂起，Sycn、Lock- 可重入锁:一个线程可多次获取该锁，Sycn、Lock- 悲观锁:每次去拿数据的时候都认为别人会修改，所以会阻塞全部其他线程 Sycn、Lock- 乐观锁:每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。cas- 显示锁和内置锁:显示锁用Lock来定义、内置锁用synchronized。- 读-写锁:为了提高性能，Java提供了读</code></pre><ol start="3"><li><p>volatile</p><ul><li>只能保证可见性，不能保证原子性</li><li>自增操作有三步，此时多线程写会出现问题</li></ul></li></ol><ol start="4"><li><p>cas</p><ul><li>操作:内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做并返回false。</li><li>解释:本地副本为A，共享内存为V，线程A要把V修改成B。某个时刻线程A要把V修改成B，如果A和V不同那么就表示有其他线程在修改V，此时就表示修改失败，否则表示没有其他线程修改，那么把V改成B。</li><li>局限:如果V被修改成V1然后又被改成V，此时cas识别不出变化，还是认为没有其他线程在修改V，此时就会有问题</li><li>局限解决:将V带上版本。</li></ul></li></ol><ol start="5"><li><p>线程不安全到底是怎么回事：</p><ul><li>一个线程写，多个线程读的时候，会造成写了一半就去读</li><li>多线程写，会造成脏数据</li></ul></li></ol><h3 id="26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"><a href="#26-Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）" class="headerlink" title="26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）"></a>26.Asynctask和线程池，GC相关（怎么判断哪些内存该GC，GC算法）</h3><ol><li><p>Asynctask：异步任务类，单线程线程池+Handler</p></li><li><p>线程池：</p><ul><li>ThreadPoolExecutor：通过Executors可以构造单线程池、固定数目线程池、不固定数目线程池。</li><li>ScheduledThreadPoolExecutor：可以延时调用线程或者延时重复调度线程。</li></ul></li></ol><ol start="3"><li><p>GC相关：重要</p><ul><li><p>搜索算法：</p><ul><li>引用计数</li><li>图搜索，可达性分析</li></ul></li><li><p>回收算法：</p><ul><li>标记清除复制：用于青年代</li><li>标记整理：用于老年代</li></ul></li></ul></li></ol><pre><code>- 堆分区：    - 青年区eden 80%、survivor1 10%、survivor2 10%    - 老年区- 虚拟机栈分区：    - 局部变量表    - 操作数栈    - 动态链接    - 方法返回地址- GC Roots:    - 虚拟机栈(栈桢中的本地变量表)中的引用的对象    - 方法区中的类静态属性引用的对象    - 方法区中的常量引用的对象    - 本地方法栈中JNI的引用的对象</code></pre><h3 id="27-网络"><a href="#27-网络" class="headerlink" title="27.网络"></a>27.网络</h3><ol><li><p>ARP协议:在IP以太网中，当一个上层协议要发包时，有了该节点的IP地址，ARP就能提供该节点的MAC地址。</p></li><li><p>HTTP HTTPS的区别:</p><ul><li><p>HTTPS使用TLS(SSL)进行加密</p></li><li><p>HTTPS缺省工作在TCP协议443端口</p></li><li><p>它的工作流程一般如以下方式:</p><ul><li>完成TCP三次同步握手</li><li>客户端验证服务器数字证书，通过，进入步骤3</li><li>DH算法协商对称加密算法的密钥、hash算法的密钥</li><li>SSL安全加密隧道协商完成</li><li>网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改</li></ul></li></ul></li></ol><ol start="3"><li><p>http请求包结构，http返回码的分类，400和500的区别</p><ul><li><p>包结构：</p><ul><li>请求：请求行、头部、数据</li><li>返回：状态行、头部、数据</li></ul></li><li><p>http返回码分类：1到5分别是，消息、成功、重定向、客户端错误、服务端错误</p></li></ul></li></ol><ol start="4"><li><p>Tcp</p><ul><li><p>可靠连接，三次握手，四次挥手</p><ul><li><p>三次握手：防止了服务器端的一直等待而浪费资源，例如只是两次握手，如果s确认之后c就掉线了，那么s就会浪费资源</p><ul><li>syn-c = x，表示这消息是x序号</li><li>ack-s = x + 1，表示syn-c这个消息接收成功。syn-s = y，表示这消息是y序号。</li><li>ack-c = y + 1，表示syn-s这条消息接收成功</li></ul></li><li><p>四次挥手：TCP是全双工模式</p><ul><li>fin-c = x , 表示现在需要关闭c到s了。ack-c = y,表示上一条s的消息已经接收完毕</li><li>ack-s = x + 1，表示需要关闭的fin-c消息已经接收到了，同意关闭</li><li>fin-s = y + 1，表示s已经准备好关闭了，就等c的最后一条命令</li><li>ack-c = y + 1，表示c已经关闭，让s也关闭</li></ul></li></ul></li></ul></li></ol><pre><code>- 滑动窗口，停止等待、后退N、选择重传- 拥塞控制，慢启动、拥塞避免、加速递减、快重传快恢复</code></pre><h3 id="28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下"><a href="#28-数据库性能优化：索引和事务，需要找本专门的书大概了解一下" class="headerlink" title="28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下"></a>28.数据库性能优化：索引和事务，需要找本专门的书大概了解一下</h3><h3 id="29-13-APK打包流程和其内容"><a href="#29-13-APK打包流程和其内容" class="headerlink" title="29.13.APK打包流程和其内容"></a>29.13.APK打包流程和其内容</h3><ol><li><p>流程</p><ul><li>aapt生成R文件</li><li>aidl生成java文件</li><li>将全部java文件编译成class文件</li><li>将全部class文件和第三方包合并成dex文件</li><li>将资源、so文件、dex文件整合成apk</li><li>apk签名</li><li>apk字节对齐</li></ul></li><li><p>内容：so、dex、asset、资源文件</p></li></ol><h3 id="30-网络劫持的类型原理：可以百度一下了解一下具体概念"><a href="#30-网络劫持的类型原理：可以百度一下了解一下具体概念" class="headerlink" title="30.网络劫持的类型原理：可以百度一下了解一下具体概念"></a>30.网络劫持的类型原理：可以百度一下了解一下具体概念</h3><ol><li>DNS劫持、欺骗、污染</li><li>http劫持：重定向、注入js，http注入、报文扩展</li></ol><h3 id="31-java类加载过程："><a href="#31-java类加载过程：" class="headerlink" title="31.java类加载过程："></a>31.java类加载过程：</h3><ol><li>加载时机：创建实例、访问静态变量或方法、反射、加载子类之前</li><li>验证：验证文件格式、元数据、字节码、符号引用的正确性</li><li>加载：根据全类名获取文件字节流、将字节流转化为静态储存结构放入方法区、生成class对象</li><li>准备：在堆上为静态变量划分内存</li><li>解析：将常量池中的符号引用转换为直接引用</li><li>初始化：初始化静态变量</li><li>书籍推荐：深入理解java虚拟机，博客推荐：<a href="https://www.jianshu.com/p/bc6d1770d92c" title="Java/Android阿里面试JVM部分理解" target="_blank" rel="noopener">https://www.jianshu.com/p/bc6d1770d92c</a></li></ol><h3 id="32-retrofit的了解"><a href="#32-retrofit的了解" class="headerlink" title="32.retrofit的了解"></a>32.retrofit的了解</h3><ol><li>动态代理创建一个接口的代理类</li><li>通过反射解析每个接口的注解、入参构造http请求</li><li>获取到返回的http请求，使用Adapter解析成需要的返回值。</li></ol><h3 id="33-bundle的数据结构，如何存储"><a href="#33-bundle的数据结构，如何存储" class="headerlink" title="33.bundle的数据结构，如何存储"></a>33.bundle的数据结构，如何存储</h3><ol><li>键值对储存</li><li>传递的数据可以是boolean、byte、int、long、float、double、string等基本类型或它们对应的数组，也可以是对象或对象数组。</li><li>当Bundle传递的是对象或对象数组时，必须实现Serializable 或Parcelable接口</li></ol><h3 id="34-listview内点击buttom并移动的事件流完整拦截过程："><a href="#34-listview内点击buttom并移动的事件流完整拦截过程：" class="headerlink" title="34.listview内点击buttom并移动的事件流完整拦截过程："></a>34.listview内点击buttom并移动的事件流完整拦截过程：</h3><ol><li><p>点下按钮的时候：</p><ul><li>产生了一个down事件，activity–&gt;phoneWindow–&gt;ViewGroup–&gt;ListView–&gt;botton,中间如果有重写了拦截方法，则事件被该view拦截可能消耗。</li><li>没拦截，事件到达了button，这个过程中建立了一条事件传递的view链表</li><li>到button的dispatch方法–&gt;onTouch–&gt;view是否可用–&gt;Touch代理</li></ul></li></ol><ol start="2"><li><p>移动点击按钮的时候:</p><ul><li>产生move事件，listView中会对move事件做拦截</li><li>此时listView会将该滑动事件消费掉</li><li>后续的滑动事件都会被listView消费掉</li></ul></li></ol><ol start="3"><li>手指抬起来时候：前面建立了一个view链表，listView的父view在获取事件的时候，会直接取链表中的listView让其进行事件消耗。</li></ol><h3 id="35-service的意义：不需要界面，在后台执行的程序"><a href="#35-service的意义：不需要界面，在后台执行的程序" class="headerlink" title="35.service的意义：不需要界面，在后台执行的程序"></a>35.service的意义：不需要界面，在后台执行的程序</h3><h3 id="36-android的IPC通信方式，线程（进程间）通信机制有哪些"><a href="#36-android的IPC通信方式，线程（进程间）通信机制有哪些" class="headerlink" title="36.android的IPC通信方式，线程（进程间）通信机制有哪些"></a>36.android的IPC通信方式，线程（进程间）通信机制有哪些</h3><ol><li>ipc通信方式：binder、contentprovider、socket</li><li>操作系统进程通讯方式：共享内存、socket、管道</li></ol><h3 id="37-操作系统进程和线程的区别"><a href="#37-操作系统进程和线程的区别" class="headerlink" title="37.操作系统进程和线程的区别"></a>37.操作系统进程和线程的区别</h3><ol><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配</li></ol><h3 id="38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。"><a href="#38-HashMap的实现过程：Capacity就是buckets的数目，Load-factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load-factor设置过小。" class="headerlink" title="38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。"></a>38.HashMap的实现过程：Capacity就是buckets的数目，Load factor就是buckets填满程度的最大比例。如果对迭代性能要求很高的话不要把capacity设置过大，也不要把load factor设置过小。</h3><ol><li><p>简单来说HashMap就是一个会自动扩容的数组链表</p></li><li><p>put过程</p><ul><li>对key的hashCode()做hash，然后再计算index;</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ul></li></ol><ol start="3"><li><p>resize：当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中</p></li><li><p>get过程</p><ul><li>根据key的hash算出数组下表</li><li>使用equals遍历链表进行比较</li></ul></li></ol><h3 id="39-mvc、mvp、mvvm："><a href="#39-mvc、mvp、mvvm：" class="headerlink" title="39.mvc、mvp、mvvm："></a>39.mvc、mvp、mvvm：</h3><ol><li><p>mvc:数据、View、Activity，View将操作反馈给Activity，Activitiy去获取数据，数据通过观察者模式刷新给View。循环依赖</p><ul><li>Activity重，很难单元测试</li><li>View和Model耦合严重</li></ul></li></ol><ol start="2"><li><p>mvp:数据、View、Presenter，View将操作给Presenter，Presenter去获取数据，数据获取好了返回给Presenter，Presenter去刷新View。PV，PM双向依赖</p><ul><li>接口爆炸</li><li>Presenter很重</li></ul></li></ol><ol start="3"><li><p>mvvm:数据、View、ViewModel，View将操作给ViewModel，ViewModel去获取数据，数据和界面绑定了，数据更新界面更新。</p><ul><li>viewModel的业务逻辑可以单独拿来测试</li><li>一个view 对应一个 viewModel 业务逻辑可以分离，不会出现全能类</li><li>数据和界面绑定了，不用写垃圾代码，但是复用起来不舒服</li></ul></li></ol><h3 id="40-java的线程如何实现"><a href="#40-java的线程如何实现" class="headerlink" title="40.java的线程如何实现"></a>40.java的线程如何实现</h3><ol><li>Thread继承</li><li>Runnale</li><li>Future</li><li>线程池</li></ol><h3 id="41-ArrayList-如何删除重复的元素或者指定的元素；"><a href="#41-ArrayList-如何删除重复的元素或者指定的元素；" class="headerlink" title="41.ArrayList 如何删除重复的元素或者指定的元素；"></a>41.ArrayList 如何删除重复的元素或者指定的元素；</h3><ol><li>删除重复：Set</li><li>删除指定：迭代器</li></ol><h3 id="42-如何设计在-UDP-上层保证-UDP-的可靠性传输；"><a href="#42-如何设计在-UDP-上层保证-UDP-的可靠性传输；" class="headerlink" title="42.如何设计在 UDP 上层保证 UDP 的可靠性传输；"></a>42.如何设计在 UDP 上层保证 UDP 的可靠性传输；</h3><ol><li>简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的超时重传，有序接受，应答确认，滑动窗口流量控制等机制,等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制。</li><li>比如使用UDP数据包+序列号，UDP数据包+时间戳等方法，在服务器端进行应答确认机制，这样就会保证不可靠的UDP协议进行可靠的数据传输。</li><li>基于udp的可靠传输协议有：RUDP、RTP、UDT</li></ol><h3 id="43-Java-中内部类为什么可以访问外部类"><a href="#43-Java-中内部类为什么可以访问外部类" class="headerlink" title="43.Java 中内部类为什么可以访问外部类"></a>43.Java 中内部类为什么可以访问外部类</h3><ol><li>因为内部类创建的时候，需要外部类的对象，在内部类对象创建的时候会把外部类的引用传递进去</li></ol><h3 id="44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树"><a href="#44-设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树-B树、红黑树" class="headerlink" title="44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)"></a>44.设计移动端的联系人存储与查询的功能，要求快速搜索联系人，可以用到哪些数据结构？数据库索引，平衡二叉树(B树、红黑树)</h3><h3 id="45-红黑树特点"><a href="#45-红黑树特点" class="headerlink" title="45.红黑树特点"></a>45.红黑树特点</h3><ol><li>root节点和叶子节点是黑色</li><li>红色节点后必须为黑色节点</li><li>从root到叶子每条路径的黑节点数量相同</li></ol><h3 id="46-linux异步和同步i-o"><a href="#46-linux异步和同步i-o" class="headerlink" title="46.linux异步和同步i/o:"></a>46.linux异步和同步i/o:</h3><ol><li><p>同步：对于client，client一直等待，但是client不挂起：主线程调用</p></li><li><p>异步：对于client，client发起请求，service好了再回调client：其他线程调用，调用完成之后进行回调</p></li><li><p>阻塞：对于service，在准备io的时候会将service端挂起，直至准备完成然后唤醒service：bio</p></li><li><p>非阻塞：对于service，在准备io的时候不会将service端挂起，而是service一直去轮询判断io是否准备完成，准备完成了就进行操作：nio、linux的select、poll、epoll</p></li><li><p>多路复用io：非阻塞io的一种优化，java nio，用一个线程去轮询多个 io端口是否可用，如果一个可用就通知对应的io请求，这使用一个线程轮询可以大大增强性能。</p><ul><li>我可以采用 多线程+ 阻塞IO 达到类似的效果，但是由于在多线程 + 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用。</li><li>而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。</li></ul></li></ol><ol start="5"><li><p>异步io：aio，用户线程完全不感知io的进行，所有操作都交给内核，io完成之后内核通知用户线程。</p><ul><li>这种io才是异步的，2、3、4都是同步io，因为内核进行数据拷贝的过程都会让用户线程阻塞。</li><li>异步IO是需要操作系统的底层支持，也就是内核支持，Java 7中，提供了Asynchronous IO</li></ul></li></ol><h3 id="47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因"><a href="#47-ConcurrentHashMap内部实现，HashTable的实现被废弃的原因" class="headerlink" title="47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:"></a>47.ConcurrentHashMap内部实现，HashTable的实现被废弃的原因:</h3><ol><li>HashTable容器在竞争激烈的并发环境下表现出效率低下的原因，是因为所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li><li>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</li></ol><h3 id="48-HandlerThread是什么"><a href="#48-HandlerThread是什么" class="headerlink" title="48.HandlerThread是什么"></a>48.HandlerThread是什么</h3><ol><li>MessageQueue + Looper + Handler</li></ol><h3 id="49-IntentService是什么"><a href="#49-IntentService是什么" class="headerlink" title="49.IntentService是什么"></a>49.IntentService是什么</h3><ol><li>含有HandlerThread的Service，可以多次startService()来多次在子线程中进行 onHandlerIntent()的调用。</li></ol><h3 id="50-class和dex"><a href="#50-class和dex" class="headerlink" title="50.class和dex"></a>50.class和dex</h3><ol><li>dvm执行的是dex格式文件，jvm执行的是class文件，android程序编译完之后生产class文件。然后dex工具会把class文件处理成dex文件，然后把资源文件和.dex文件等打包成apk文件。</li><li>dvm是基于寄存器的虚拟机，而jvm执行是基于虚拟栈的虚拟机。寄存器存取速度比栈快的多，dvm可以根据硬件实现最大的优化，比较适合移动设备。</li><li>class文件存在很多的冗余信息，dex工具会去除冗余信息，并把所有的class文件整合到dex文件中。减少了I/O操作，提高了类的查找速度</li></ol><h3 id="51-内存泄漏"><a href="#51-内存泄漏" class="headerlink" title="51.内存泄漏"></a>51.内存泄漏</h3><ol><li>其他线程持有一个Listener，Listener操作activity。那么在线程么有完毕的时候，activity关闭了，原本是要被回收的但是，不能被回收。</li><li>例如Handler导致的内存泄漏，Handler就相当于Listener。</li><li>在activity关闭的时候注意停止线程，或者将Listener的注册取消</li><li>使用弱引用，这样即使Listener持有了activity，在GC的时候还是会被回收</li><li>工具:LeakCanary</li></ol><h3 id="52-过度绘制、卡顿优化"><a href="#52-过度绘制、卡顿优化" class="headerlink" title="52.过度绘制、卡顿优化:"></a>52.过度绘制、卡顿优化:</h3><ol><li><p>过度绘制：</p><ul><li>移除Window默认的Background：getWidow.setBackgroundDrawable(null);</li><li>移除XML布局文件中非必需的Background</li><li>减少布局嵌套(扁平化的一个体现，减少View数的深度，也就减少了View树的遍历时间，渲染的时候，前后期的工作，总是按View树结点来)</li><li>在引入布局文件里面，最外层可以用merge替代LinearLayout,RelativeLayout，这样把子UI元素直接衔接在include位置</li><li>工具：HierarchyViewer 查看视图层级</li></ul></li></ol><ol start="2"><li>卡顿优化：16ms数据更新</li></ol><h3 id="53-apk瘦身"><a href="#53-apk瘦身" class="headerlink" title="53.apk瘦身:"></a>53.apk瘦身:</h3><ol><li>classes.dex：通过代码混淆，删掉不必要的jar包和代码实现该文件的优化</li><li>资源文件：通过Lint工具扫描代码中没有使用到的静态资源</li><li>图片资源：使用tinypng和webP，下面详细介绍图片资源优化的方案,矢量图</li><li>SO文件将不用的去掉，目前主流app一般只放一个arm的so包</li></ol><h3 id="54-ANR的形成，各个组件上出现ARN的时间限制是多少"><a href="#54-ANR的形成，各个组件上出现ARN的时间限制是多少" class="headerlink" title="54.ANR的形成，各个组件上出现ARN的时间限制是多少"></a>54.ANR的形成，各个组件上出现ARN的时间限制是多少</h3><ol><li>只要是主线程耗时的操作就会ARN  如io</li><li>broadcast超时时间为10秒  按键无响应的超时时间为5秒 前台service无响应的超时时间为20秒，后台service为200秒</li></ol><h3 id="55-Serializable和Parcelable-的区别"><a href="#55-Serializable和Parcelable-的区别" class="headerlink" title="55.Serializable和Parcelable 的区别"></a>55.Serializable和Parcelable 的区别</h3><ol><li>P 消耗内存小</li><li>网络传输用S  程序内使用P</li><li>S将数据持久化方便</li><li>S使用了反射 容易触发垃圾回收 比较慢</li></ol><h3 id="56-Sharedpreferences源码简述"><a href="#56-Sharedpreferences源码简述" class="headerlink" title="56.Sharedpreferences源码简述"></a>56.Sharedpreferences源码简述</h3><ol><li>储存于硬盘上的xml键值对，数据多了会有性能问题</li><li>ContextImpl记录着SharedPreferences的重要数据，文件路径和实例的键值对</li><li>在xml文件全部内加载到内存中之前，读取操作是阻塞的，在xml文件全部内加载到内存中之后，是直接读取内存中的数据</li><li>apply因为是异步的没有返回值, commit是同步的有返回值能知道修改是否提交成功</li><li>多并发的提交commit时，需等待正在处理的commit数据更新到磁盘文件后才会继续往下执行，从而降低效率; 而apply只是原子更新到内存，后调用apply函数会直接覆盖前面内存数据，从一定程度上提高很多效率。 3.edit()每次都是创建新的EditorImpl对象.</li><li>博客推荐：<a href="https://www.jianshu.com/p/102f25cf64e3" title="全面剖析SharedPreferences" target="_blank" rel="noopener">全面剖析SharedPreferences</a></li></ol><h3 id="57-操作系统如何管理内存的："><a href="#57-操作系统如何管理内存的：" class="headerlink" title="57.操作系统如何管理内存的："></a>57.操作系统如何管理内存的：</h3><ol><li>使用寄存器进行将进程地址和物理内存进行映射</li><li>虚拟内存进行内存映射到硬盘上增大内存</li><li>虚拟内存是进行内存分页管理</li><li>页表实现分页，就是 页+地址偏移。</li><li>如果程序的内存在硬盘上，那么就需要用页置换算法来将其调入内存中：先进先出、最近未使用最少等等</li><li>博客推荐：<a href="https://www.jianshu.com/p/aecff59430fa" title="现代操作系统部分章节笔记" target="_blank" rel="noopener">现代操作系统部分章节笔记</a></li></ol><h3 id="58-浏览器输入地址到返回结果发生了什么"><a href="#58-浏览器输入地址到返回结果发生了什么" class="headerlink" title="58.浏览器输入地址到返回结果发生了什么"></a>58.浏览器输入地址到返回结果发生了什么</h3><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h3 id="59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"><a href="#59-java泛型类型擦除发生在什么时候，通配符有什么需要注意的。" class="headerlink" title="59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。"></a>59.java泛型类型擦除发生在什么时候，通配符有什么需要注意的。</h3><ol><li>发生在编译的时候</li><li>PECS，extends善于提供精确的对象 A是B的子集，Super善于插入精确的对象 A是B的超集</li><li>博客推荐：<a href="https://www.jianshu.com/p/4e4751b5bbbb" title="Effective Java笔记（不含反序列化、并发、注解和枚举）" target="_blank" rel="noopener">Effective Java笔记（不含反序列化、并发、注解和枚举</a>、<a href="https://www.jianshu.com/p/6006a3284f55" title="android阿里面试java基础锦集" target="_blank" rel="noopener">android阿里面试java基础锦集</a>、</li></ol><h3 id="60-activity的生命周期"><a href="#60-activity的生命周期" class="headerlink" title="60.activity的生命周期"></a>60.activity的生命周期</h3><ol><li>a启动b，后退键再到a的生命周期流程：a.create–&gt;a.start–&gt;a.resume–&gt;a.pause–&gt;b.create–&gt;b.start–&gt;b.resume–&gt;b界面绘制–&gt;a.stop–&gt;b.pause–&gt;b.stop–&gt;b.destroy–&gt;a.restart–&gt;a.start–&gt;a.resume</li><li>意外销毁会调用saveInstance，重新恢复的时候回调用restoreInstance。储存数据的时候使用了委托机制，从activity–&gt;window–&gt;viewGroup–&gt;view 会递归调用save来保持本view的数据，restore则是递归恢复本view数据。我们可以在里面做一些自己需要的数据操作。</li></ol><h3 id="61-面试常考的算法"><a href="#61-面试常考的算法" class="headerlink" title="61.面试常考的算法"></a>61.面试常考的算法</h3><ol><li>快排、堆排序为首的各种排序算法</li><li>链表的各种操作：判断成环、判断相交、合并链表、倒数K个节点、寻找成环节点</li><li>二叉树、红黑树、B树定义以及时间复杂度计算方式</li><li>动态规划、贪心算法、简单的图论</li><li>推荐书籍：算法导论，将图论之前的例子写一遍</li></ol><h3 id="62-Launcher进程启动另外一个进程的过程：启动一个app"><a href="#62-Launcher进程启动另外一个进程的过程：启动一个app" class="headerlink" title="62.Launcher进程启动另外一个进程的过程：启动一个app"></a>62.Launcher进程启动另外一个进程的过程：<a href="http://www.cnblogs.com/tiantianbyconan/p/5017056.html" title="启动一个app" target="_blank" rel="noopener">启动一个app</a></h3><h3 id="63-开源框架源码"><a href="#63-开源框架源码" class="headerlink" title="63.开源框架源码"></a>63.开源框架源码</h3><ol><li><p>Fresco</p><ul><li><p>mvc框架：</p><ul><li>Controller控制数据显示在Hierarchy中的Drawable的显隐</li><li>ImagePipeline在Controller中负责进行数据获取，返回的数据是CloseableImage</li><li>Drawee把除了初始化之外的操作全部交给Holder去做，Holder持有Controller和Hierarchy</li></ul></li></ul></li></ol><pre><code>- Drawable层次以及绘制：    - 如果要绘制一次Drawable就调用invalidateSelf()来触发onDraw()    - Drawable分为：容器类(保存一些Drawable)、自我绘制类(进度条)、图形变换类(scale、rotate、矩阵变换)、动画类(内部不断刷新，进行webp和gif的帧绘制)    - ImagePipeline返回的CloseableImage是由一个个DrawableFactory解析成Drawable的    - webp和gif动画是由jni代码解析的，然后其他静态图片是根据不同的android平台使用BitmapFactory来解析的- 职责链模式：producer不做操作标n，表示只是提供一个consumer。获取图片--》解码图片缓存Producer--》后台线程Producer--》client图片处理producer(n)--》解码producer(n)--》旋转或剪裁producer(n)--》编码图片内存缓存producer--》读硬盘缓存producer--》写硬盘缓存producer(n)--》网络producer提供CloseableImage《--解码图片缓存consumer《--client图片处理consumer《--解码consumer《--旋转或剪裁consumer《--编码图片内存缓存consumer《--写硬盘缓存consumer《--图片数据- 内存缓存：    - 一个CountingLruMap保存已经没有被引用的缓存条目，一个CountingLruMap保存所有的条目包括没有引用的条目。每当缓存策略改变和一定时间缓存配置的更新的时候，就会将 待销毁条目Map中的条目一个个移除，直到缓存大小符合配置。    - 这里的引用计数是用Fresco组件实现的引用计数器。    - 缓存有一个代理类，用来追踪缓存的存取。    - CountingLruMap是使用LinkedHashMap来储存数据的。- 硬盘缓存：    - DefaultDiskStorage使用Lru策略。    - 为了不让所有的文件集中在一个文件中，创建很多命名不同的文件夹，然后使用hash算法把缓存文件分散    - DiskStorageCache封装了DefaultDiskStorage，不仅进行缓存存取追踪，并且其在内存里面维持着一个 &lt;key,value&gt; 的键值对，因为文件修改频繁，所有只是定时刷新，因此如果在内存中找不到，还要去硬盘中找一次。    - 删除硬盘的缓存只出现在硬盘数据大小超限的时候，此时同时也会删除缓存中的key，所以不会出现内存中有key，但是硬盘上没有的情况。    - 在插入硬盘数据的时候，采用的是插入器的形式。返回一个Inserter，在Inserter.writeData()中传入一个CallBack(里面封装了客户端插入数据的逻辑和文件引用)，让内部实现调用CallBack的逻辑来插入文件数据，前面写的文件后缀是.temp,只有调用commit()之后才会修改后缀，让文件对客户端可见。    - 使用了java提供的FileTreeVisitor来遍历文件- 对象池：    - 使用数组来存储一个桶，桶内部是一个Queue。数组下标是数据申请内存的byte大小，桶内部的Queue存的是内存块的。所以数组使用的是稀疏数组    - 申请内存的方式有两种 1.java堆上开辟的内存 2.ashme 的本地内存中开辟的内存7.设计模式：Builder、职责链、观察者、代理、组合、享元、适配器、装饰者、策略、生产者消费者、提供者8.自定义计数引用：类似c++智能指针    1.使用一个静态IdentityHashMap &lt;储存需要被计数引用的对象,其被引用的次数&gt;    2.用SharedReference分装需要被计数引用的对象，提供一个销毁资源的销毁器，提供一个静态工厂方法来复制自己，复制一个引用计数加一。提供一个方法销毁自己，表示自己需要变成无人引用的对象了，此时引用计数减一。    3.引用计数归零，销毁器将销毁资源，如bitmap的recycle或者是jni内存调用jni方法归还内存。9.博客推荐：Android Fresco源码文档翻译、从零开始撸一个Fresco之硬盘缓存、从零开始撸一个Fresco之gif和Webp动画、从零开始撸一个Fresco之内存缓存、从零开始撸一个Fresco之总结</code></pre><ol start="2"><li><p>oKhttp：</p><ul><li><p>同步和异步：</p><p>  1.异步使用了Dispatcher来将存储在 Deque 中的请求分派给线程池中各个线程执行。<br>  2.当任务执行完成后，无论是否有异常，finally代码段总会被执行，也就是会调用Dispatcher的finished函数，它将正在运行的任务Call从队列runningAsyncCalls中移除后，主动的把缓存队列向前走了一步。</p></li></ul></li></ol><pre><code>- 连接池：    - 一个Connection封装了一个socket，ConnectionPool中储存s着所有的Connection，StreamAllocation是引用计数的一个单位    - 当一个请求获取一个Connection的时候要传入一个StreamAllocation，Connection中存着一个弱引用的StreamAllocation列表，每当上层应用引用一次Connection，StreamAllocation就会加一个。反之如果上层应用不使用了，就会删除一个。    - ConnectionPool中会有一个后台任务定时清理StreamAllocation列表为空的Connection。5分钟时间，维持5个socket- 选择路线与建立连接    - 选择路线有两种方式：        - 无代理，那么在本地使用DNS查找到ip，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源        - 有代理HTTP：设置socket的ip为代理地址的ip，设置socket的端口为代理地址的端口        - 代理好处：HTTP代理会帮你在远程服务器进行DNS查询，可以减少DNS劫持。    - 建立连接        - 连接池中已经存在连接，就从中取出(get)RealConnection，如果没有命中就进入下一步        - 根据选择的路线(Route)，调用Platform.get().connectSocket选择当前平台Runtime下最好的socket库进行握手        - 将建立成功的RealConnection放入(put)连接池缓存        - 如果存在TLS，就根据SSL版本与证书进行安全握手        - 构造HttpStream并维护刚刚的socket连接，管道建立完成- 职责链模式：缓存、重试、建立连接等功能存在于拦截器中网络请求相关，主要是网络请求优化。网络请求的时候遇到的问题- 博客推荐：[Android数据层架构的实现 上篇](https://www.jianshu.com/p/60e5ebf0096a &quot;Android数据层架构的实现 上篇&quot;)、[Android数据层架构的实现 下篇](https://www.jianshu.com/p/5def7b42d223 &quot;Android数据层架构的实现 下篇&quot;)</code></pre><ol start="3"><li><p>okio</p><ul><li><p>简介；</p><ul><li>sink：自己–》别人</li><li>source：别人–》自己</li><li>BufferSink：有缓存区域的sink</li><li>BufferSource：有缓存区域的source</li><li>Buffer：实现了3、4的缓存区域，内部有Segment的双向链表，在在转移数据的时候，只需要将指针转移指向就行</li></ul></li></ul></li></ol><pre><code>- 比java io的好处：    - 减少内存申请和数据拷贝    - 类少，功能齐全，开发效率高- 内部实现：    - Buffer的Segment双向链表，减少数据拷贝    - Segment的内部byte数组的共享，减少数据拷贝    - SegmentPool的共享和回收Segment    - sink和source中被实际操作的其实是Buffer，Buffer可以充当sink和source    - 最终okio只是对java io的封装，所有操作都是基于java io 的</code></pre><hr><pre><code>作者：何时夕链接：https://www.jianshu.com/p/cf5092fa2694來源：简书</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-android事件分发机制，请详细说下整个流程&quot;&gt;&lt;a href=&quot;#1-android事件分发机制，请详细说下整个流程&quot; class=&quot;headerlink&quot; title=&quot;1.android事件分发机制，请详细说下整个流程&quot;&gt;&lt;/a&gt;1.android事件
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="面试题" scheme="http://9aiplay.com/categories/Android/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="面试题" scheme="http://9aiplay.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="转载" scheme="http://9aiplay.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Android进阶之光笔记</title>
    <link href="http://9aiplay.com/record/a0295d89/"/>
    <id>http://9aiplay.com/record/a0295d89/</id>
    <published>2019-06-13T02:16:51.000Z</published>
    <updated>2019-06-13T03:59:38.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h1><p>使用了注解，三大类，http请求方法注解，标记类注解，参数类注解</p><p>@path 动态配置url地址</p><p>@Query 动态指定查询条件</p><p>@QueryMap 动态指定查询条件组</p><p>@Field 传输数据类型为键值对</p><p>@Body 传输数据类型JSON字符串</p><p>@Part 单个文件上传</p><p>@PartMap 多个文件上传</p><p>@Multipart 允许多个@Part</p><p>Retrofit使用了建造者模式构建出来，使用动态代理获取到定义的接口类。</p><p>Builder方法中调用Platform的get方法，get方法最终调用的是findPlatform方法，根据不同的运行平台来提供不同的线程池。</p><p>build方法中首先做了baseurl==null的判断，baseurl必须穿，</p><pre><code>- 之后将我们之前通过callFactory设置的OKhttpclient赋值给callFactory，如果我们没有设置，则直接创建okhttpclient。- callbackExecutor用来回调传递到UI线程。- adapterFactories主要用于储存对Call进行转化的对象    - adapterFactories列表默认会添加defaultCallAdapterFactory，指的是ExecutorCallAdatperFactory。- converterFactories主要用于储存转化数据对象</code></pre><p>create方法返回了一个Proxy.newProxyInstance动态代理对象。</p><p>当调用接口类对象的方法时，最终会调用InvocationHandler的invoke方法。</p><pre><code>invoke方法中会调用loadServiceMethod（method），这个method就是我们定义的接口类中的方法。loadServiceMethod中首先会从serviceMethodCache查询传入的方法是否有缓存，如果有的话就用缓存的ServiceMethod，如果没有就创建一个并加入serviceMethodCache中缓存起来。    ServiceMethod的build方法构造步骤        1. 第一步调用createCallAdapter，最终会调用adapterFactories添加的对象的get方法，会得到一个CallAdapter对象，CallAdatper中有两个方法            - responseType方法，会返回数据的真实类型(就是最后接口返回数据的实体类)            - adapt方法，会创建ExecutorCallbackCall，它会将call的回调转发至UI线程。        2. 第二步调用calladapter的responseType方法得到的是接口返回数据的真实类型。        3. 第三步调用createResponseConverter方法来遍历converterFactories列表中储存的Converter.Factory，并返回一个合适的Converter用来转换对象，        （之前构建Retrofit时调用了addConverterFactory(GsonConverterFactory.create(),这段代码将GsonConverterFactory(Converter.Factory的子类)添加到converterFactories列表中，标示返回的数据支持转换为Json对象）        4. 第四步遍历parseMethodAnnotation方法来对请求方式和请求地址进行解析        5. 第五步对方法中的参数注解进行解析(比如@Query，@Part)。        6. 最后创建ServiceMethod类返回。调用了loadServiceMethod方法后会创建OkhttpCall,紧接着调用serviceMethod.callAdapter.adapt(okHttpCall)，callAdatper的adapt方法前面讲过，它会创建ExecutorCallbackCall，并传入OkHttpCall。    ExecutorCallbackCall是对Call的封装，他主要添加了通过callbackExecutor将请求回调到UI线程。    我们得到Call对象后会调用它的enqueue方法，其实调用的是ExecutorCallbackCall的enqueue方法。    ExecutorCallbackCall的enqueue方法最终调用的是OkhttpCall的enqueue方法。        enqueue中的回调onResponse方法中，调用了parseResponse方法根据返回的不同状态码Code值来做不同的操作，顺利的话会调用toResponse方法，        返回的是responseConverter.convert(body); 这个responseConverter就是ServiceMethod的build方法中调用createResponseConverter方法返回的Converter，此前我们传入的是GsonConverterFatroy。            GsonConverterFactory中有一个方法responseBodyConverter，最终会创建GsonResponseBodyConverter。            在GsonResponseBodyConverter的convert方法中会降回调的数据转换为JSON格式        因此，我们知道了此前调用responseConverter.convert是为了转换为特定的数据格式。Call的enqueue方法主要做的就是用Okhttp来请求网络，将返回的Response进行数据转换并回调给UI线程。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Retrofit&quot;&gt;&lt;a href=&quot;#Retrofit&quot; class=&quot;headerlink&quot; title=&quot;Retrofit&quot;&gt;&lt;/a&gt;Retrofit&lt;/h1&gt;&lt;p&gt;使用了注解，三大类，http请求方法注解，标记类注解，参数类注解&lt;/p&gt;
&lt;p&gt;@path 
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>如何在Markdown中插入音视频</title>
    <link href="http://9aiplay.com/record/b8d2a7a6/"/>
    <id>http://9aiplay.com/record/b8d2a7a6/</id>
    <published>2019-04-19T08:20:03.000Z</published>
    <updated>2019-09-19T08:59:47.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="在Markdown中加入视频"><a href="#在Markdown中加入视频" class="headerlink" title="在Markdown中加入视频"></a>在Markdown中加入视频</h2><p>直接复制下面代码放到需要展示视频的地方，记得修改成自己的封面图和视频连接</p><pre><code>&lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;https://9aiplay.com/images/5.jpg&quot;&gt;  &lt;source id=&quot;mp4&quot; src=&quot;https://9aiplay.com/video/5.mp4&quot; type=&quot;video/mp4&quot;&gt;  &lt;/video&gt;</code></pre><p>上面的代码效果如下：</p><video id="video" controls preload="none" poster="https://9aiplay.com/images/5.jpg">      <source id="mp4" src="https://9aiplay.com/video/5.mp4" type="video/mp4">      </video><p>##在Markdown中加入音频<br>直接复制下面代码放到需要播放音频的地方，记得修改成自己的音频连接</p><pre><code>&lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt;  &lt;source id=&quot;mp3&quot; src=&quot;https://9aiplay.com/audio/1.mp3&quot;&gt;  &lt;/audio&gt;</code></pre><p>上面的代码效果如下：</p><audio id="audio" controls preload="none">      <source id="mp3" src="https://9aiplay.com/audio/1.mp3">      </audio>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;在Markdown中加入视频&quot;&gt;&lt;a href=&quot;#在Markdown中加入视频&quot; class=&quot;headerlink&quot; title=&quot;在Markdown中加入视频&quot;&gt;&lt;/a&gt;在Markdown中加入视频&lt;/h2&gt;&lt;p&gt;直接复制下面代码放到需要展示视频的地方，记得
      
    
    </summary>
    
    
      <category term="Markdown" scheme="http://9aiplay.com/categories/Markdown/"/>
    
    
      <category term="Utils" scheme="http://9aiplay.com/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>hexo常用命令</title>
    <link href="http://9aiplay.com/record/58913/"/>
    <id>http://9aiplay.com/record/58913/</id>
    <published>2019-02-14T08:18:14.000Z</published>
    <updated>2019-02-15T05:53:26.309Z</updated>
    
    <content type="html"><![CDATA[<p>以下命令需要在本地Blog路径下执行</p><h2 id="Step1-创建文章"><a href="#Step1-创建文章" class="headerlink" title="Step1 创建文章"></a>Step1 创建文章</h2><pre><code>$ hexo new &quot;My New Post&quot;$ hexo n &quot;My New Post&quot;    //安装hexo-asset-image后可使用</code></pre><h2 id="Step2-编辑文章"><a href="#Step2-编辑文章" class="headerlink" title="Step2 编辑文章"></a>Step2 编辑文章</h2><pre><code>文章头部加---title: //此处填写文章名date: //此处填写发布日期tags:   - //此处填写标签名(可多个)---</code></pre><p>由于在首页中显示文章内容使用的是 post.content 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个 <a id="more"></a> 标记。添加了这个标记之后，post.excerpt 将会获取到标记之前的内容</p><p>之后的内容大家可以随意Diy啦<br>编辑md文件建议使用Typora软件或MarkdownPad</p><p>###关于文章添加图片：<br>​    1 把本地Blog文件下的配置文件（非主题下）_config.yml里的post_asset_folder:选项设置为true</p><p>​    2 在本地Blog路径下执行npm install hexo-asset-image –save （用于下载安装一个可以上传本地图片的插件）</p><p>​    3 运行hexo n “xxxx”来生成md博文</p><p>​    会发现在/source/_posts文件夹中除了xxxx.md`文件还生成了一个同名文件夹</p><p>​    4最后在xxxx.md引入图片时，先把图片复制到xxxx文件夹中 然后在xxxx.md中按照markdown的格式引入图片：</p><pre><code>![你想输入的替代文字](xxxx/图片名.jpg)</code></pre><h2 id="Step3-清除缓存-（可省略-建议使用）"><a href="#Step3-清除缓存-（可省略-建议使用）" class="headerlink" title="Step3 清除缓存 （可省略 建议使用）"></a>Step3 清除缓存 （可省略 建议使用）</h2><pre><code>$ hexo clean</code></pre><p>清除缓存文件 db.json 和已生成的静态文件 public</p><p>当网站显示异常时可以执行这条命令试试</p><p>##Step4 生成静态文件<br>    $ hexo generate<br>    $ hexo g      //简写</p><p>这步骤就相当于程序的编译，如果有错误的话，在终端会有相应的提示信息</p><p>如果没有错误的话 可以继续往下执行</p><p>##Step5 启动本地服务器 （可省略）<br>    $ hexo server<br>    $ hexo s      //简写</p><p>用于预览主题，默认地址： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><h2 id="Step6-部署到远程站点"><a href="#Step6-部署到远程站点" class="headerlink" title="Step6 部署到远程站点"></a>Step6 部署到远程站点</h2><pre><code>$ hexo deploy$ hexo d       //简写</code></pre><p>上述步骤结束后 恭喜你 一篇博文完成啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下命令需要在本地Blog路径下执行&lt;/p&gt;
&lt;h2 id=&quot;Step1-创建文章&quot;&gt;&lt;a href=&quot;#Step1-创建文章&quot; class=&quot;headerlink&quot; title=&quot;Step1 创建文章&quot;&gt;&lt;/a&gt;Step1 创建文章&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;$ hexo new &amp;quot;My New Post&amp;quot;
$ hexo n &amp;quot;My New Post&amp;quot;    //安装hexo-asset-image后可使用&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;Step2-编辑文章&quot;&gt;&lt;a href=&quot;#Step2-编辑文章&quot; class=&quot;headerlink&quot; title=&quot;Step2 编辑文章&quot;&gt;&lt;/a&gt;Step2 编辑文章&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;文章头部加
---
title: //此处填写文章名
date: //此处填写发布日期
tags: 
  - //此处填写标签名(可多个)
---&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于在首页中显示文章内容使用的是 post.content 我们如果想在主页中实现文章的部分内容渲染，需要在文章中添加一个
    
    </summary>
    
    
      <category term="Hexo" scheme="http://9aiplay.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://9aiplay.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Android获取Imageview上的图片</title>
    <link href="http://9aiplay.com/record/a0295d89/"/>
    <id>http://9aiplay.com/record/a0295d89/</id>
    <published>2018-08-17T01:24:15.000Z</published>
    <updated>2018-08-17T01:24:19.325Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Android获取Imageview上的图片"><a href="#Android获取Imageview上的图片" class="headerlink" title="Android获取Imageview上的图片"></a>Android获取Imageview上的图片</h2><pre><code>private Bitmap view2Bitmap(ImageView imageView) {    imageView.setDrawingCacheEnabled(true);    imageView.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED), View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));    imageView.layout(0, 0, imageView.getMeasuredWidth(), imageView.getMeasuredHeight());    imageView.buildDrawingCache();    Bitmap bitmap = Bitmap.createBitmap(imageView.getDrawingCache());    imageView.setDrawingCacheEnabled(false);    return bitmap;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Android获取Imageview上的图片&quot;&gt;&lt;a href=&quot;#Android获取Imageview上的图片&quot; class=&quot;headerlink&quot; title=&quot;Android获取Imageview上的图片&quot;&gt;&lt;/a&gt;Android获取Imageview上的
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android重启app功能</title>
    <link href="http://9aiplay.com/record/3dbfa497/"/>
    <id>http://9aiplay.com/record/3dbfa497/</id>
    <published>2018-07-03T09:55:34.000Z</published>
    <updated>2019-09-19T05:16:35.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-FLAG-ACTIVITY-CLEAR-TOP"><a href="#使用-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="使用 FLAG_ACTIVITY_CLEAR_TOP"></a>使用 FLAG_ACTIVITY_CLEAR_TOP</h2><p>特点：不杀进程,不清除缓存,启动快</p><pre><code>Intent intent = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);startActivity(intent);</code></pre><h2 id="使用-AlarmManager"><a href="#使用-AlarmManager" class="headerlink" title="使用 AlarmManager"></a>使用 AlarmManager</h2><p>特点：杀进程,短暂黑屏,启动慢</p><pre><code>Intent intent = getBaseContext().getPackageManager().getLaunchIntentForPackage(getBaseContext().getPackageName());PendingIntent restartIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_ONE_SHOT);AlarmManager mgr = (AlarmManager)getSystemService(Context.ALARM_SERVICE);       mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 10, restartIntent); android.os.Process.killProcess(android.os.Process.myPid());</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用-FLAG-ACTIVITY-CLEAR-TOP&quot;&gt;&lt;a href=&quot;#使用-FLAG-ACTIVITY-CLEAR-TOP&quot; class=&quot;headerlink&quot; title=&quot;使用 FLAG_ACTIVITY_CLEAR_TOP&quot;&gt;&lt;/a&gt;使用 FLAG_
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="重启app" scheme="http://9aiplay.com/categories/Android/%E9%87%8D%E5%90%AFapp/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="重启app" scheme="http://9aiplay.com/tags/%E9%87%8D%E5%90%AFapp/"/>
    
  </entry>
  
  <entry>
    <title>AutoSearchBug自动联网查找bug</title>
    <link href="http://9aiplay.com/record/44941/"/>
    <id>http://9aiplay.com/record/44941/</id>
    <published>2018-07-03T02:15:44.000Z</published>
    <updated>2018-07-03T09:13:49.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这是一款可以在项目崩溃时获取异常<br>自动联网在Stack Overflow,百度或其他平台上寻找回答链接和详情</p></blockquote><hr><blockquote><p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80900149" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80900149</a><br>简书:<a href="https://www.jianshu.com/p/625519ce9f8a" target="_blank" rel="noopener">https://www.jianshu.com/p/625519ce9f8a</a><br>Github:<a href="https://github.com/SHPDZY/AutoSearchBug" target="_blank" rel="noopener">https://github.com/SHPDZY/AutoSearchBug</a></p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>android通过UncaughtExceptionHandler来实现获取应用全局的crash信息<br>启动一个服务来完成联网查找回答</p><pre><code>Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {    public void uncaughtException(final Thread thread, final Throwable ex) {        String errorMsg = getErrorMsg(ex);        Intent intent = new Intent(mApp, AutoSearchBugService.class);        intent.putExtra(ERROR_MSG, errorMsg);        intent.putExtra(MAX_SIZE, maxSize);        intent.putExtra(SHOW_ANSWER, showAnswer);        intent.putExtra(SEARCH_TYPE, searchType);        mApp.startService(intent);        mUEH.uncaughtException(thread, ex);    }};public class AutoSearchBugService extends Service implements AutoSearchBugGlobal {    ···    private void search(final String errorMsg, int maxSize, final int showAnswer, int searchType) {        AutoSearchBugHttpUtil.doGet(                        AutoSearchBugAPI.SEARCH_URL +                         AutoSearchBugAPI.PAGE_SIZE + maxSize +                        AutoSearchBugAPI.ERROR_MSG + errorMsg.replace(&quot; &quot;, &quot;%20&quot;) +                        AutoSearchBugAPI.SHOW_ANSWER + showAnswer +                         AutoSearchBugAPI.SEARCH_TYPE + searchType,                new AutoSearchBugHttpUtil.HResponse() {                    @Override                    public void onStart() {                        StringBuffer log = new StringBuffer();                        log.append(LINE_START);                        log.append(SEARCHING);                        log.append(LINE_END);                        log(log);                    }                    @Override                    public void onFinish(String msg) {                        resolveLog(msg, errorMsg, showAnswer);                        stopSelf();                    }                    @Override                    public void onError(String error) {                        StringBuffer log = new StringBuffer();                        log.append(String.format(ASB_ERROR, error));                        log.append(LINE_END);                        log(log);                        stopSelf();                    }                });    }···}</code></pre><p>服务端通过Jsoup来解析html</p><pre><code>@RestController@RequestMapping(&quot;/android&quot;)@Api(&quot;android接口&quot;)public class SearchBugApi {    ···    /**     * 通过errorMsg来查找回答     * @param page          获取几条数据     * @param errorMsg      crash信息     * @param showAnswer    是否显示回答详情     * @param type          0搜索stackoverflow 1搜索baidu     * @return     */    @GetMapping(&quot;autosearchbug&quot;)    public R autosearchbug(int page, String errorMsg, int showAnswer, int type) {        switch (type) {            case 0:                return getStackOverFlow(page, errorMsg, showAnswer);            case 1:                return getBD(page, errorMsg);            default:                return getStackOverFlow(page, errorMsg, showAnswer);        }    }     private R getStackOverFlow(int page, String errorMsg, int showAnswer) {        String url = &quot;https://stackoverflow.com/search?q=&quot; + errorMsg;        List&lt;AutoSearchBugEntity&gt; autoSearchBugList = new ArrayList();        try {            Document doc = Jsoup.connect(url).get();            ···            return R.ok().putData(autoSearchBugList);        } catch (IOException e) {            e.printStackTrace();            return R.error(e.getMessage());        }    }    ···}</code></pre><h2 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h2><h3 id="Android-Studio-引入"><a href="#Android-Studio-引入" class="headerlink" title="Android Studio 引入"></a>Android Studio 引入</h3><h4 id="第1步-将JitPack存储库添加到您的构建文件"><a href="#第1步-将JitPack存储库添加到您的构建文件" class="headerlink" title="第1步 将JitPack存储库添加到您的构建文件"></a>第1步 将JitPack存储库添加到您的构建文件</h4><p>将其添加到存储库末尾的根build.gradle中：</p><pre><code>allprojects {     repositories {         ...         maven { url &apos;https://jitpack.io&apos; }     } }</code></pre><h4 id="第2步-添加依赖关系"><a href="#第2步-添加依赖关系" class="headerlink" title="第2步 添加依赖关系"></a>第2步 添加依赖关系</h4><pre><code>dependencies {       implementation &apos;com.github.SHPDZY:AutoSearchBug:1.0.1&apos;}</code></pre><h3 id="Eclipse-引入"><a href="#Eclipse-引入" class="headerlink" title="Eclipse 引入"></a>Eclipse 引入</h3><p>建议使用As，方便版本更新。</p><pre><code>dependencies {       compile project(path: &apos;:AutoSearchBug&apos;)}</code></pre><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code>AutoSearchBugControl.getBuilder()        .setMaxSize(3)    //显示数量        .showAnswer(true) //true显示回答详情        .setSearchType(0) //0在stackoverflow搜索  1：在百度搜索        .init();</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>默认初始化未显示回答详情<br><img src="http://blog.9aiplay.com/zb_users/upload/2018/07/20180703150844153060172493277.png" alt="效果图"></p><p>自定义初始化显示详情<br><img src="http://blog.9aiplay.com/zb_users/upload/2018/07/20180703145628153060098854731.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;这是一款可以在项目崩溃时获取异常&lt;br&gt;自动联网在Stack Overflow,百度或其他平台上寻找回答链接和详情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;CSDN:&lt;a href=&quot;https://blog.
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="AutoSearchBug" scheme="http://9aiplay.com/categories/Android/AutoSearchBug/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="AutoSearchBug" scheme="http://9aiplay.com/tags/AutoSearchBug/"/>
    
  </entry>
  
  <entry>
    <title>Android常用UI库(来源网络)</title>
    <link href="http://9aiplay.com/record/2a70c22e/"/>
    <id>http://9aiplay.com/record/2a70c22e/</id>
    <published>2018-07-02T02:06:50.000Z</published>
    <updated>2018-07-03T09:16:32.153Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>收集Android常用的Ui库</p></blockquote><hr><blockquote><p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80901082" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80901082</a><br>简书:<a href="https://www.jianshu.com/p/baa34723c64b" target="_blank" rel="noopener">https://www.jianshu.com/p/baa34723c64b</a><br>Github:<a href="https://github.com/SHPDZY/CommonViewForAndroid" target="_blank" rel="noopener">https://github.com/SHPDZY/CommonViewForAndroid</a></p></blockquote><h1 id="PickTime"><a href="#PickTime" class="headerlink" title="PickTime"></a>PickTime</h1><p>日期选择控件<br>项目地址:<br><a href="https://github.com/codbking/PickTime" target="_blank" rel="noopener">https://github.com/codbking/PickTime</a><br><img src="../common-android-ui-library/1.gif" alt></p><hr><h1 id="Android-PickerView"><a href="#Android-PickerView" class="headerlink" title="Android-PickerView"></a>Android-PickerView</h1><p>这是一款仿iOS的PickerView控件，有时间选择器和选项选择器<br>项目地址:<br><a href="https://github.com/Bigkoo/Android-PickerView" target="_blank" rel="noopener">https://github.com/Bigkoo/Android-PickerView</a><br><img src="../common-android-ui-library/2.gif" alt></p><hr><h1 id="MPAndroidChart"><a href="#MPAndroidChart" class="headerlink" title="MPAndroidChart"></a>MPAndroidChart</h1><p>强大的Android图表视图/图形视图库<br>项目地址:<br><a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="noopener">https://github.com/PhilJay/MPAndroidChart</a><br><img src="../common-android-ui-library/3-1.png" alt><br><img src="../common-android-ui-library/3-2.png" alt><br><img src="../common-android-ui-library/3-3.png" alt></p><hr><h1 id="PhotoView"><a href="#PhotoView" class="headerlink" title="PhotoView"></a>PhotoView</h1><p>实现支持缩放的ImageView for Android。<br>项目地址:<br><a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">https://github.com/chrisbanes/PhotoView</a><br><img src="../common-android-ui-library/4-1.png" alt><br><img src="../common-android-ui-library/4-2.png" alt></p><hr><h1 id="CircleImageView"><a href="#CircleImageView" class="headerlink" title="CircleImageView"></a>CircleImageView</h1><p>适用于Android的圆形ImageView<br>项目地址:<br><a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="noopener">https://github.com/hdodenhof/CircleImageView</a><br><img src="../common-android-ui-library/5.png" alt></p><hr><h1 id="AVLoadingIndicatorView"><a href="#AVLoadingIndicatorView" class="headerlink" title="AVLoadingIndicatorView"></a>AVLoadingIndicatorView</h1><p>这是一款Android的精彩加载动画的集合，虽然作业已经弃用，但还是一个有助于学习的项目<br>项目地址:<br><a href="https://github.com/81813780/AVLoadingIndicatorView" target="_blank" rel="noopener">https://github.com/81813780/AVLoadingIndicatorView</a><br><img src="../common-android-ui-library/6.gif" alt></p><hr><h1 id="MaterialViewPager"><a href="#MaterialViewPager" class="headerlink" title="MaterialViewPager"></a>MaterialViewPager</h1><p>一款Material Design ViewPager<br>项目地址:<br><a href="https://github.com/florent37/MaterialViewPager" target="_blank" rel="noopener">https://github.com/florent37/MaterialViewPager</a><br><img src="../common-android-ui-library/7.png" alt></p><hr><h1 id="JiaoZiVideoPlayer"><a href="#JiaoZiVideoPlayer" class="headerlink" title="JiaoZiVideoPlayer"></a>JiaoZiVideoPlayer</h1><p>一款简单强大方便自定义的播放器<br>项目地址:<br><a href="https://github.com/lipangit/JiaoZiVideoPlayer" target="_blank" rel="noopener">https://github.com/lipangit/JiaoZiVideoPlayer</a><br><img src="../common-android-ui-library/8.png" alt></p><hr><h1 id="UltimateRecyclerView"><a href="#UltimateRecyclerView" class="headerlink" title="UltimateRecyclerView"></a>UltimateRecyclerView</h1><p>一个多功能的RecycleView，带有拉动刷新，加载更多，滑动解散，拖放和动画，粘滞标题，滚动显示或隐藏工具栏和FAB等许多功能。<br>项目地址:<br><a href="https://github.com/cymcsg/UltimateRecyclerView" target="_blank" rel="noopener">https://github.com/cymcsg/UltimateRecyclerView</a><br><img src="../common-android-ui-library/9.gif" alt>)<img src="../common-android-ui-library/9-4.gif" alt>)<img src="../common-android-ui-library/9-2.gif" alt>)<img src="../common-android-ui-library/9-3.gif" alt></p><hr><h1 id="RoundedImageView"><a href="#RoundedImageView" class="headerlink" title="RoundedImageView"></a>RoundedImageView</h1><p>一款简单的ImageView，支持圆角，椭圆和圆形。<br>项目地址:<br><a href="https://github.com/vinc3m1/RoundedImageView" target="_blank" rel="noopener">https://github.com/vinc3m1/RoundedImageView</a><br><img src="../common-android-ui-library/10.png" alt></p><hr><h1 id="XRecyclerView"><a href="#XRecyclerView" class="headerlink" title="XRecyclerView"></a>XRecyclerView</h1><p>一款可以添加head实现了pullrefresh，loadingmore的简单方便的RecycleView<br>项目地址:<br><a href="https://github.com/XRecyclerView/XRecyclerView" target="_blank" rel="noopener">https://github.com/XRecyclerView/XRecyclerView</a><br><img src="../common-android-ui-library/11.gif" alt></p><hr><h1 id="持续更新中······"><a href="#持续更新中······" class="headerlink" title="持续更新中······"></a>持续更新中······</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;收集Android常用的Ui库&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;CSDN:&lt;a href=&quot;https://blog.csdn.net/qq82001945/article/details/809010
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="Ui库" scheme="http://9aiplay.com/categories/Android/Ui%E5%BA%93/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="Ui库" scheme="http://9aiplay.com/tags/Ui%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>独立服务器自建Git仓库</title>
    <link href="http://9aiplay.com/record/699722cf/"/>
    <id>http://9aiplay.com/record/699722cf/</id>
    <published>2018-06-25T02:54:18.000Z</published>
    <updated>2018-07-03T02:12:53.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><pre><code>环境：  服务器 CentOS7.3 + git（version 1.8..31）客户端 Windows7 + git（version 2.16.2.windows.1）</code></pre><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>Linux 做为服务器端系统，Windows 作为客户端系统，分别安装 Git</p><h3 id="服务器端安装"><a href="#服务器端安装" class="headerlink" title="服务器端安装"></a>服务器端安装</h3><pre><code>[root@VM_0_16_centos ~]# yum install -y git  </code></pre><p>安装完后，查看 Git 版本</p><pre><code>[root@VM_0_16_centos ~]# git --version  git version 1.8.3.1</code></pre><h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><p>下载    <a href="https://git-for-windows.github.io/" target="_blank" rel="noopener">Git for Windows</a></p><p>安装完之后，可以使用 Git Bash 作为命令行客户端。</p><p>安装完之后，查看 Git 版本</p><blockquote><p>$ git –version<br>git version 2.16.2.windows.1</p></blockquote><h2 id="服务器端创建-git-用户，用来管理-Git-服务，并为-git-用户设置密码"><a href="#服务器端创建-git-用户，用来管理-Git-服务，并为-git-用户设置密码" class="headerlink" title="服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码"></a>服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码</h2><pre><code>[root@localhost home]# id gitid: git：no such user[root@localhost home]# useradd git[root@localhost home]# passwd git</code></pre><h2 id="服务器端创建-Git-仓库"><a href="#服务器端创建-Git-仓库" class="headerlink" title="服务器端创建 Git 仓库"></a>服务器端创建 Git 仓库</h2><p>设置 /home/data/git/gittest.git 为 Git 仓库</p><p>然后把 Git 仓库的 owner 修改为 git</p><pre><code>[root@localhost home]# mkdir -p data/git/gittest.git[root@localhost home]# git init --bare data/git/gittest.gitInitialized empty Git repository in /home/data/git/gittest.git/[root@localhost home]# cd data/git/[root@localhost git]# chown -R git:git gittest.git/</code></pre><h2 id="客户端-clone-远程仓库"><a href="#客户端-clone-远程仓库" class="headerlink" title="客户端 clone 远程仓库"></a>客户端 clone 远程仓库</h2><p>在硬盘里找一个文件夹来存放，然后从 Linux Git 服务器上 clone 项目</p><blockquote><p>$ git clone <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a>:/home/data/gittest.git</p></blockquote><p><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/git_clone.png" alt="git clone"></p><p>当第一次连接到目标 Git 服务器时会得到一个提示：</p><blockquote><p>The authenticity of host ‘192.168.56.101 (192.168.56.101)’ can’t be established.<br>RSA key fingerprint is SHA256:Ve6WV/SCA059EqoUOzbFoZdfmMh3B259nigfmvdadqQ.<br>Are you sure you want to continue connecting (yes/no)? </p></blockquote><p>选择 yes：</p><blockquote><p>Warning: Permanently added ‘192.168.56.101’ (RSA) to the list of known hosts.</p></blockquote><p>此时 C:\Users\用户名.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句。<br><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/known.png" alt="known"></p><h2 id="客户端创建-SSH-公钥和私钥"><a href="#客户端创建-SSH-公钥和私钥" class="headerlink" title="客户端创建 SSH 公钥和私钥"></a>客户端创建 SSH 公钥和私钥</h2><blockquote><p>$ ssh-keygen -t rsa -C “<a href="mailto:472323087@qq.com" target="_blank" rel="noopener">472323087@qq.com</a>“</p></blockquote><p><img src="../%E7%8B%AC%E7%AB%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%BB%BAGit%E4%BB%93%E5%BA%93/ssh-keygen.png" alt></p><p>此时 C:\Users\用户名.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub</p><p>id_rsa 是私钥</p><p>id_rsa.pub 是公钥</p><h2 id="服务器端-Git-打开-RSA-认证"><a href="#服务器端-Git-打开-RSA-认证" class="headerlink" title="服务器端 Git 打开 RSA 认证"></a>服务器端 Git 打开 RSA 认证</h2><p>进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释：</p><pre><code>RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys</code></pre><p>保存并重启 sshd 服务：</p><pre><code>[root@localhost ssh]# service sshd restart</code></pre><p>由 AuthorizedKeysFile 得知公钥的存放路径是 .ssh/authorized_keys，实际上是 $Home/.ssh/authorized_keys，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 /home/git/.ssh/authorized_keys</p><p>在 /home/git/ 下创建目录 .ssh</p><pre><code>[root@localhost git]# cd /home/git/  [root@localhost git]# pwd  /home/git  [root@localhost git]# mkdir .ssh  [root@localhost git]# ls -a   . .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla .ssh</code></pre><p>然后把 .ssh 文件夹的 owner 修改为 git</p><pre><code>[root@localhost git]# chown -R git:git .ssh  [root@localhost git]# ll -a  总用量 32  drwx------. 5 git  git  4096 8月  28 20:04 .  drwxr-xr-x. 8 root root 4096 8月  28 19:32 ..  -rw-r--r--. 1 git  git18 10月 16 2014 .bash_logout  -rw-r--r--. 1 git  git   176 10月 16 2014 .bash_profile  -rw-r--r--. 1 git  git   124 10月 16 2014 .bashrc  drwxr-xr-x. 2 git  git  4096 11月 12 2010 .gnome2  drwxr-xr-x. 4 git  git  4096 5月   8 12:22 .mozilla  </code></pre><blockquote><p>drwxr-xr-x. 2 git  git  4096 8月  28 20:08 .ssh  </p></blockquote><h2 id="将客户端公钥导入服务器端-home-git-ssh-authorized-keys-文件"><a href="#将客户端公钥导入服务器端-home-git-ssh-authorized-keys-文件" class="headerlink" title="将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件"></a>将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件</h2><p>回到 Git Bash 下，导入文件：</p><blockquote><p>$ ssh <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a> ‘cat &gt;&gt; .ssh/authorized_keys’ &lt; ~/.ssh/id_rsa.pub</p></blockquote><p>需要输入服务器端 git 用户的密码</p><p>或或者用FileZilla类似软件直接复制</p><pre><code>[root@localhost .ssh]# cd /home/git/.ssh/  [root@localhost .ssh]# cat id_rsa.pub &gt;&gt; authorized_keys</code></pre><p>回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件：</p><pre><code>[root@localhost git]# cd .ssh  [root@localhost .ssh]# ll  总用量 4  -rw-rw-r--. 1 git git 398 8月  28 20:08 authorized_keys</code></pre><p>可以查看一下是否是客户端生成的公钥。</p><p>重要：</p><p>修改 .ssh 目录的权限为 700</p><p>修改 .ssh/authorized_keys 文件的权限为 600</p><pre><code>[root@localhost git]# chmod 700 .ssh  [root@localhost git]# cd .ssh  [root@localhost .ssh]# chmod 600 authorized_keys   </code></pre><h2 id="客户端再次-clone-远程仓库"><a href="#客户端再次-clone-远程仓库" class="headerlink" title="客户端再次 clone 远程仓库"></a>客户端再次 clone 远程仓库</h2><blockquote><p>$ git clone <a href="mailto:git@192.168.56.101" target="_blank" rel="noopener">git@192.168.56.101</a>:/home/data/git/gittest.git</p></blockquote><p>项目已经成功 clone 了。</p><h2 id="将git仓库文件自动同步到nginx文件目录下，可以通过外网访问"><a href="#将git仓库文件自动同步到nginx文件目录下，可以通过外网访问" class="headerlink" title="将git仓库文件自动同步到nginx文件目录下，可以通过外网访问"></a>将git仓库文件自动同步到nginx文件目录下，可以通过外网访问</h2><pre><code>[root@localhost git]# cd /home/data/git/gittest.git[root@localhost git]# touch post-receive[root@localhost git]# vi post-receive</code></pre><p>编辑这个 post-receive 文件：</p><pre><code>/#!/bin/bash -lGIT_REPO=/home/data/git/gittest.git  TMP_GIT_CLONE=/home/data/git/gittest_tmp  PUBLIC_WWW=/home/data/git/gittest  rm -rf ${TMP_GIT_CLONE}  git clone $GIT_REPO $TMP_GIT_CLONErm -rf ${PUBLIC_WWW}/*  cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}</code></pre><p>这个脚本可以实现完全更新，即先删除原网站内所有内容，再拷贝新仓库内容到网站目录，可以避免一些不必要的问题。</p><p>还要给脚本加上执行权限：</p><pre><code>[root@localhost git]# chmod +x post-receive</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;环境：  
服务器 CentOS7.3 + git（version 1.8..31）
客户端 Windows
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://9aiplay.com/categories/Linux/"/>
    
      <category term="Git" scheme="http://9aiplay.com/categories/Linux/Git/"/>
    
    
      <category term="Linux" scheme="http://9aiplay.com/tags/Linux/"/>
    
      <category term="Git" scheme="http://9aiplay.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>LogCatDialog</title>
    <link href="http://9aiplay.com/record/aedd56c1/"/>
    <id>http://9aiplay.com/record/aedd56c1/</id>
    <published>2018-06-20T04:30:45.000Z</published>
    <updated>2018-07-03T09:15:12.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一款可以在手机中打开logcat控制台</p></blockquote><hr><blockquote><p>CSDN:<a href="https://blog.csdn.net/qq82001945/article/details/80900233" target="_blank" rel="noopener">https://blog.csdn.net/qq82001945/article/details/80900233</a><br>简书:<a href="https://www.jianshu.com/p/32837cb6ee7e" target="_blank" rel="noopener">https://www.jianshu.com/p/32837cb6ee7e</a><br>Github:<a href="https://github.com/SHPDZY/LogCatDialog" target="_blank" rel="noopener">https://github.com/SHPDZY/LogCatDialog</a></p></blockquote><ul><li>方便快捷</li><li>支持内容搜索</li><li>支持自定义标题</li><li>支持根据tag筛选</li><li>支持根据log级别显示</li></ul><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><pre><code>LogCatControl.getInstance(this)        .setTitle(&quot;自定义标题&quot;)        .setSearchContent(&quot;自定义搜索内容&quot;)        .setSearchTag(&quot;自定义Tag&quot;)        .setShowGrade(3) //设置显示级别:0 所有，1 系统，2 警告,3 错误        .show();</code></pre><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p>首页写了几个功能测试用例，您可根据需求组合搭配使用。</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622135955152964719564867.png" alt="首页"></p><p>默认方式打开</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622140009152964720960527.png" alt="默认方式打开"></p><p>自定义标题方式打开</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622135958152964719853179.png" alt="自定义标题方式打开"></p><p>自定义搜索内容方式打开</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622140004152964720426154.png" alt="自定义搜索内容方式打开"></p><p>自定义目标TAG方式打开</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622140001152964720177860.png" alt="自定义目标TAG方式打开"></p><p>自定义LOG级别方式打开</p><p><img src="http://blog.9aiplay.com/zb_users/upload/2018/06/20180622140007152964720766879.png" alt="自定义LOG级别方式打开"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;一款可以在手机中打开logcat控制台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;CSDN:&lt;a href=&quot;https://blog.csdn.net/qq82001945/article/details/80900233&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq82001945/article/details/80900233&lt;/a&gt;&lt;br&gt;简书:&lt;a href=&quot;https://www.jianshu.com/p/32837cb6ee7e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/32837cb6ee7e&lt;/a&gt;&lt;br&gt;Github:&lt;a href=&quot;https://github.com/SHPDZY/LogCatDialog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/SHPDZY/LogCatDialog&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;方便快捷&lt;/li&gt;
&lt;li&gt;支持内容搜索&lt;/li&gt;
&lt;li&gt;支持自定义标题&lt;/li&gt;
&lt;li&gt;支持根据tag筛选&lt;/li&gt;
&lt;li&gt;支持根据log级别显示&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="View" scheme="http://9aiplay.com/categories/Android/View/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="View" scheme="http://9aiplay.com/tags/View/"/>
    
      <category term="Logcat" scheme="http://9aiplay.com/tags/Logcat/"/>
    
  </entry>
  
  <entry>
    <title>Activity的4种启动模式</title>
    <link href="http://9aiplay.com/record/a0295d89/"/>
    <id>http://9aiplay.com/record/a0295d89/</id>
    <published>2018-06-15T04:09:22.000Z</published>
    <updated>2018-07-03T02:12:53.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Activity4种启动模式"><a href="#Activity4种启动模式" class="headerlink" title="Activity4种启动模式"></a>Activity4种启动模式</h2><ul><li>standard</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ul><p>下面我来分别做介绍。</p><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>顾名思义，standard英文意思就是“标准的”。</p><p>也就是说这种启动模式是默认的，我们平时在开发中使用最多的就是Standard模式的。</p><p>如果一个Activity的启动模式被设置成standard，那么它可以无限制的创建。你每一次通过Intent去启动这种模式的Activity都会重新创建一个。</p><p>大家可以想象一下邮箱里的收件箱（假设我们将打开邮件的Activity的启动模式设置为Standard，当然这也是默认的模式）里有10封邮件。我们给查看邮件的Activity起名为CheckEmailActivity,我点击第一封邮件将会打开一个CheckEmailActivity，当我看完之后点击下一封邮件，另一个CheckEmailActivity又会被创建，这样如果我们将10封邮件全部看完，那在Activity任务栈中将会有10个CheckEmailActivity，而且如果我想回到收件箱页面还必须点10次返回键！想想是不是很可怕？</p><p>所以说standard模式虽然很常用，但也不是适用于任何场合。<br>　　<br>另外说一点，standard模式在Android 5.0（Lollipop）之前和之后是有区别的。<br>　　<br><strong>Android Lollipop之前</strong></p><p>standard模式的Activity总是会被创建在启动它的Activity同一个任务栈中顶端（任务栈是一个栈结构，先进后出 First In Last Out），就算他们来自不同的应用。<br>　　<br>想象一个场景，如果你在A应用中要分享一个本地图片，这样会打开系统的图片查看应用中的图片选择器Activity，虽然这两个Activity来自不同的应用，但Android系统仍将会把他们放在同一个任务栈中，即A应用的任务栈中。<br>　　<br><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/1.png" alt></p><p><strong>Android Lollipop之后</strong></p><p>如果将要启动的Activity和启动它的Activity来自同一个应用，那没话说，和Lollipop之前一样，新的Activity会被创建在当前任务栈中的顶端。</p><p>但是如果它们来自不同的应用，那就会创建一个新的任务栈，再把要启动的Activity放在新的任务栈中，这时这个新启动的Activity就是新创建的任务站点的根Activity。如下图所示：<br>　　<br><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/2.png" alt></p><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>顾名思义，singleTop的意思就是“在顶部只能有一个”。</p><p>这种启动模式非常类似于standard，但是也有一些 区别：</p><p>如果在启动这种模式的Activity的时候，当前任务栈的顶端已经存在了相同的Activity，那系统就不会再创建新的，而是回调任务栈中已经存在的该Activity的onNewIntent( )方法。请看下面的示意图：</p><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/3.png" alt></p><p>也正因为SingleTop启动模式的特殊性，所以在开发时，如果指定了一个Activity的启动模式是singleTop的那就应该既要重写onCreated()方法用于应对第一次创建的情况，也要重写onNewIntent( )方法来应对重复创建的情况。<br>其实大家可以想象一下，这种启动模式的应用场景。Android既然提供了这种启动模式，说明肯定有应有场景需要这样的方式。其实最常用的场景就是搜索，比方说我们在搜索框中输入想要搜索的内容点击搜索进入SearchResultActivty(搜索结果页)查看搜索的结果（一般我们也会在搜索结果页提供搜索框，这样用户无需点击返回键回到上一个页面再在搜索框中输入搜索内容点击搜索），如果此时用户还想搜点别的东西，就可以直接在当前的搜索结果页SearchResultActivty中的搜索框输入搜索内容继续搜索。</p><p>大家想象一下，如果我们把SearchResultActivty的启动模式设置为Standard的话会是什么样的景象。比如我们连着搜了10个内容，那就会启动10个不同的SearchResultActivty，然而这些SearchResultActivty功能完全一样，完全没有必要创建这么多，而且还有一个和上一节中的邮箱一样的问题，就是用户搜索结束想回到首页，那就还得按10次返回键才能回到首页，- -！</p><p>这时，singleTop启动模式就派上用场了，我们首先把SearchResultActivty的启动模式设置为singleTop，这样用户在SearchResultActivty页面中继续搜索的时候，我们只需把用户要搜索的内容放在Intent里面然后启动SearchResultActivty，这时系统并不会重新创建新的SearchResultActivty，而是回调当前任务栈栈顶的SearchResultActivty的onNewIntent()方法来接收带有用户搜索内容信息的Intent，然后我们拿到用户搜索内容后调搜索接口，并根据接口返回内容重新刷新布局即可，似不似很神奇？其实我们在上一节提到的邮箱的问题，也是用这种方式来解决的，原理和搜索一样的。</p><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>这种启动模式的Activity在Android系统中只允许存在一个实例。</p><p>如果系统中已经存在了该种启动模式的目标Activity，则系统并不会重新创建一个目标Activity，而是首先将持有目标Activity的整个任务栈都会被置于前台（用户可见），并且通过onNewIntent( )方法将启动目标Activity的Intent传递给目标Activity，置于目标Activity拿到这个Intent之后要做什么操作，系统就不管了，随便你拿来干什么，哼~。</p><p>但是这里有个问题，就是目标Activity和源Activity是不是来自同一应用。</p><p>源Activity和目标Activity来自同一个应用<br>这种情况还要分两种情况说：</p><p>当前系统中还没有目标Activity的实例<br>这种情况最简单，直接在当前的任务栈中创建SingleTask模式的Activity并置于栈顶即可。</p><p>当前系统中已经存在目标Activity的实例<br>这种情况比较特殊，因为系统会把任务栈中目标Activity之上的所有Activity销毁，以让目标Activity处在栈顶的位置。</p><p>这里还要还要再提醒大家的是，因为目标Activity已经存在，系统不会重新创建，而是通过onNewIntent()的方式把Intent传递过来，这点和singleTop模式有些类似。注意了，这里让我们回想一下文章开头的我所说的场景，如何让用户在支付完成页直接跳转到首页，并把不需要的Activity销毁？SingleTask启动模式是不是刚好和我们的需求一致？请看下面的示意图：</p><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/4.png" alt></p><p><strong>源Activity和目标Activity来自不同应用</strong><br>这种情况也要分两种情况说：</p><p><strong>当前系统中还没有目标Activity的实例</strong><br>这时系统首先会看任务管理器中是否有目标Actvity所在应用的任务栈？如果有的话，那就直接在目标Activity所在应用的任务栈的栈顶创建即可。</p><p>如果任务管理器中没有目标Activity所在应用的任务栈，系统就会创建其所在应用的任务栈和目标Activity，并且把目标Activity作为新建任务栈的根Activity。如下图所示：　　</p><p><strong>当前系统中已经存在目标Activity的实例</strong><br>目标Activity所在任务栈会被置于前台（即用户可见），而且也会把目标Activity之上的所有Actvity全部销毁。</p><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>这种启动模式和singleTask<strong>几乎一样</strong>，它也只允许系统中存在一个目标Activity，包括上面我们所说的SingleTask的一些特性singleInstance都有。<strong>唯一不同的是，持有目标Activity的任务栈中只能有目标Activity一个Actvitiy，不能再有别的Activity，对！ 就是承包了这个任务栈！。</strong></p><p>其实从这种启动模式的名字也可以看出来它表示的意思，singleInstance直译过来就是“单一实例”，什么意思呢？这话啊有两层意思，我来给你分析分析：1. 跟系统说，“我是独一无二的，不许和我一样的人存在！”，这就是说系统中存在一个目标Activity。；2. 跟任务栈说，“我是独一无二的，不许你心里再装别的人！”，这就是说持有目标Activity的任务栈中只能有目标Activity一个Activity。这样说是不是好理解一些，哈哈~<br>　　<br>所以，如果要启动singleInstance模式的Activity,那只能新创建一个任务栈用来放它，因为人家说了，“我是独一无二的！”。同样的，如果从这种启动模式的Activity中启动别的Activity，那不好意思，我不管你是不是和我处在同一个应用，我所在的任务栈只能拥有我一个人，您呐，另外让系统给你创建一个任务栈待着去吧。</p><p>好了，至此我们介绍了Activity的4种启动模式了，也大致了解了每种启动模式的特点了，那接下里的问题就是怎么使用呢？问题又抛出来了，好，让我们接着往下看。</p><h2 id="怎么使用启动模式？"><a href="#怎么使用启动模式？" class="headerlink" title="怎么使用启动模式？"></a>怎么使用启动模式？</h2><p>有两种方式来使用或者说设置Activity的启动模式：</p><h3 id="方式1：在AndroidMenifest-xml文件中设置："><a href="#方式1：在AndroidMenifest-xml文件中设置：" class="headerlink" title="方式1：在AndroidMenifest.xml文件中设置："></a>方式1：在AndroidMenifest.xml文件中设置：</h3><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/5.png" alt></p><p>看到没有，在<activity>标签中设置android:launchMode=”<strong><strong>“属性即可，</strong></strong>即我们上面所说的四种启动模式。</activity></p><h3 id="方式2：通过为Intent添加标识来设置"><a href="#方式2：通过为Intent添加标识来设置" class="headerlink" title="方式2：通过为Intent添加标识来设置"></a>方式2：通过为Intent添加标识来设置</h3><p><img src="../Activity%E7%9A%844%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/6.png" alt></p><p>看到没有，这里使用Intent的addFlags()方法来添加一些标志，其实这个addFlags()不光可以用来设置Activity的启动模式，还能做很多事情，它的作用是给Intent添加一些附加属性。具体的可以参见Android api哈~<br>　　<br>那我们想设置Activity的启动模式应该给addFlags()方法设置哪些参数呢？来，接着往下看：</p><ul><li><strong>FLAG_ACTIVITY_NEW_TASK</strong><ul><li>与”singleTask”启动模式的作用一样。</li></ul></li><li><strong>FLAG_ACTIVITY_SINGLE_TOP</strong><ul><li>与”singleTop”启动模式的作用一样。</li></ul></li><li><strong>FLAG_ACTIVITY_CLEAR_TOP</strong><ul><li>这个标识的意思比较特殊。它不对应于我们上面所说的启动模式中的任何一种，我们来看一下android api中对这个标识的说明：</li></ul></li></ul><blockquote><p>如果正在启动的 Activity 已在当前任务中运行，则会销毁当前任务顶部的所有 Activity，并通过onNewIntent()<br>将此 Intent 传递给 Activity 已恢复的实例（现在位于顶部），而不是启动该 Activity 的新实例。</p></blockquote><p>大家可能会发现，通过addFlags()的方式来设置启动模式有局限性，只能显示的设置“singleTask”和“singleTop”两种启动模式，而并没有对应“standard”和“singleInstance”启动模式的标识。是的，android api文档中确实只只有以上三种标识用来设置启动模式，而且第三种“*<em>FLAG_ACTIVITY_CLEAR_TOP<br>*</em>”还不对应任何一种启动模式，难道可以算作第5种启动模式？遗憾的是，我现在也不清楚是怎么回事。<br>　　<br>但是实际开发中，我们一般都是在AndroidMenifest.xml文件中去设置Activity的启动模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Activity4种启动模式&quot;&gt;&lt;a href=&quot;#Activity4种启动模式&quot; class=&quot;headerlink&quot; title=&quot;Activity4种启动模式&quot;&gt;&lt;/a&gt;Activity4种启动模式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;standard&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>java线程方法join</title>
    <link href="http://9aiplay.com/record/a45191ef/"/>
    <id>http://9aiplay.com/record/a45191ef/</id>
    <published>2018-06-03T05:18:55.000Z</published>
    <updated>2018-07-03T02:12:53.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>　　Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：</p><pre><code>public class JoinTest {        public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();                /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：         程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，         并返回t1线程继续执行直到线程t1执行完毕         所以结果是t1线程执行完后，才到主线程执行，         相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会*/                t1.join();        t2.start();    }}class ThreadJoinTest extends Thread{        public ThreadJoinTest(String name){                super(name);    }    @Override        public void run(){                for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>　　上面程序结果是先打印完小明线程，在打印小东线程；　　</p><p>　　上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：</p><pre><code>public class JoinTest {        public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();                /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，         * main线程和t1线程之间执行顺序由串行执行变为普通的并行执行         */        t1.join(10);                t2.start();    }}class ThreadJoinTest extends Thread{        public ThreadJoinTest(String name){                super(name);    }    @Override        public void run(){                for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>　　上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。</p><p>　　所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。</p><p>　　</p><h2 id="join与start调用顺序问题"><a href="#join与start调用顺序问题" class="headerlink" title="join与start调用顺序问题"></a>join与start调用顺序问题</h2><p>　　上面的讨论大概知道了join的作用了，那么，入股 join在start前调用，会出现什么后果呢？先看下面的测试结果</p><pre><code>public class JoinTest {        public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);                /**join方法可以在start方法前调用时，并不能起到同步的作用     */        t1.join();        t1.start();               //Thread.yield();                t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面代码执行结果是：小明和小东线程交替打印。</p><p>所以得到以下结论：join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。</p><h2 id="join方法实现原理"><a href="#join方法实现原理" class="headerlink" title="join方法实现原理"></a>join方法实现原理</h2><p>　　有了上面的例子，我们大概知道join方法的作用了，那么，join方法实现的原理是什么呢？</p><p>　　其实，join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态，具体看下面的源码：</p><pre><code>public final synchronized void join(long millis)    throws InterruptedException {            long base = System.currentTimeMillis();            long now = 0;          if (millis &lt; 0) {                    throw new IllegalArgumentException(&quot;timeout value is negative&quot;);    }           if (millis == 0) {                    while (isAlive()) {            wait(0);        }    } else {                    while (isAlive()) {                            long delay = millis - now;                            if (delay &lt;= 0) {                                    break;            }            wait(delay);                 now = System.currentTimeMillis() - base;        }    }}</code></pre><p>　　从源码中可以看到：join方法的原理就是调用相应线程的wait方法进行等待操作的，例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; title=&quot;作用&quot;&gt;&lt;/a&gt;作用&lt;/h2&gt;&lt;p&gt;　　Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="Java" scheme="http://9aiplay.com/categories/Android/Java/"/>
    
      <category term="线程" scheme="http://9aiplay.com/categories/Android/Java/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="join" scheme="http://9aiplay.com/categories/Android/Java/%E7%BA%BF%E7%A8%8B/join/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="Java" scheme="http://9aiplay.com/tags/Java/"/>
    
      <category term="线程" scheme="http://9aiplay.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="join" scheme="http://9aiplay.com/tags/join/"/>
    
  </entry>
  
  <entry>
    <title>fragment和activity的区别</title>
    <link href="http://9aiplay.com/record/a7570806/"/>
    <id>http://9aiplay.com/record/a7570806/</id>
    <published>2018-05-19T04:22:25.000Z</published>
    <updated>2018-07-03T02:12:53.691Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>Fragment是到Android3.0+ 以后，Android新增了Fragments，在没有 Fragment 之前，一个屏幕只能放一个 Activity。这是一个起源时间大家要知道是什么时候开始引入的。</p></li><li><p>.Activity 代表了一个屏幕的主体,而Fragment可以作为Activity的一个组成元素。<br>一个Activity可以有若干个（0或n）Fragment构成。你可以把Fragment想象成Activity中的一个控件，只不过相对于一般控件，Fragment与Activity联系更为紧密，随着Activity的生命周期变化，Fragment也随之相应不同的生命周期函数。<br>Fragment 从功能上讲相当于一个子活动（Activity），它可以让多个活动放到同一个屏幕上，也就是对用户界面和功能的重用，因为对于大屏设备来说，纯粹的 Activity 有些力不从心。</p></li><li><p>Fragment 像是一个子活动，但是 Fragment 不是 Activity 的扩展，因为 Fragment 扩展自 android.app 中的 Object，而 Activity 是 Context 的子类。Fragment 有自己的视图层级结构，有自己的活动周期，还可以像活动一样响应后退按钮，Fragment 还有一个用作其初始化参数的包（Bundle），类似 Activity，Fragment 也可由系统自动保存并在以后还原。当系统还原 Fragment 时，它调用默认的构造函数（没有参数），然后将此Bundle还原到新创建的 Fragment 中，所以无论新建还是还原 Fragment，都要经过两个步骤：(1)调用默认构造函数(2)传入新的或者保存起来的Bundle。</p></li><li><p>一个Activity可以运行多个 Fragment，Fragment 切换时，由 FragmentTransaction 执行，切换时，上一个 Fragment 可以保存在后退栈中（Back Stack），这里的后退栈由 FragmentManager 来管理，注意 Fragment 和 Activity 的后退栈是有区别的：Activity 的后退栈由系统管理，而 Fragment 的后退栈由所在的Activity 管理。</p></li><li><p>Fragment不能脱离Activity而存在，只有Activity才能作为接收intent的载体。其实两者基本上是载体和组成元素的关系。</p></li><li><p>Fragment用来描述一些行为或一部分用户界面在一个Activity中，你可以合并多个fragment在一个单独的activity中建立多个UI面板，同时重用fragment在多个activity中.你可以认为fragment作为一个activity中的一节模块，fragment有自己的生命周期，接收自己的输入事件，你可以添加或移除从运行中的activity.一个fragment必须总是嵌入在一个activity中，同时fragment的生命周期受activity而影响，举个例子吧，当activity暂停，那么所有在这个activity的fragments将被destroy释放。然而当一个activity在运行比如resume时，你可以单独的操控每个fragment，比如添加或删除。不过因为Fragment和Activity的生命周期都比较复杂，我们分别对比下:创建一个fragment你必须创建一个Fragment的子类或存在的子类，比如类似下面的代码</p></li></ul><pre><code>public static class AndroidFragment extends Fragment{   @Override   public View onCreateView(LayoutInflaterinflater, ViewGroup container,Bundle savedInstanceState) {            return inflater.inflate(R.layout.android_fragment,container, false);    }   }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;Fragment是到Android3.0+ 以后，Android新增了Fragments，在没有 Fragment 之前，一个屏幕只能放一个 Activity。这是一个起源时间大家要知道是什么时候开始引入的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.Activ
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="Fragment" scheme="http://9aiplay.com/categories/Android/Fragment/"/>
    
      <category term="Activity" scheme="http://9aiplay.com/categories/Android/Fragment/Activity/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="Fragment" scheme="http://9aiplay.com/tags/Fragment/"/>
    
      <category term="Activity" scheme="http://9aiplay.com/tags/Activity/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask源码分析</title>
    <link href="http://9aiplay.com/record/160afc6c/"/>
    <id>http://9aiplay.com/record/160afc6c/</id>
    <published>2018-05-16T03:59:21.000Z</published>
    <updated>2018-07-03T02:12:53.676Z</updated>
    
    <content type="html"><![CDATA[<p>说到Android中的异步执行AsyncTask一定不陌生，今天就让我们来到它的内部一探究竟。</p><h2 id="定义一个异步任务"><a href="#定义一个异步任务" class="headerlink" title="定义一个异步任务"></a>定义一个异步任务</h2><p>首先简单写一个使用例子：</p><pre><code>private class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; {    @Override    protected void onPreExecute() {      super.onPreExecute();    }    @Override    protected String doInBackground(String... strings) {      return null;    }    @Override    protected void onPostExecute(String s) {      super.onPostExecute(s);    }  }</code></pre><h2 id="执行该任务"><a href="#执行该任务" class="headerlink" title="执行该任务"></a>执行该任务</h2><pre><code>new MyAsyncTask().execute(&quot;&quot;);</code></pre><p>我们从任务的起点execute()看起：</p><pre><code>@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {    return executeOnExecutor(sDefaultExecutor, params);}@MainThreadpublic final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,        Params... params) {    if (mStatus != Status.PENDING) {        switch (mStatus) {            case RUNNING:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task is already running.&quot;);            case FINISHED:                throw new IllegalStateException(&quot;Cannot execute task:&quot;                        + &quot; the task has already been executed &quot;                        + &quot;(a task can be executed only once)&quot;);        }    }    mStatus = Status.RUNNING;    onPreExecute();    mWorker.mParams = params;    exec.execute(mFuture);    return this;}</code></pre><p>可以看到这个方法必须在主线程中调用，方法中对状态过了一个过滤和变更，回调onPreExecute方法让我们在任务执行前进行一些操作。里面涉及到了2个关键变量mWorker和mFuture。<br>它们都是在构造函数那进行初始化：</p><pre><code>public AsyncTask(@Nullable Looper callbackLooper) {    mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper()        ? getMainHandler()        : new Handler(callbackLooper);    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {        public Result call() throws Exception {            mTaskInvoked.set(true);            Result result = null;            try {                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);                //noinspection unchecked                result = doInBackground(mParams);                Binder.flushPendingCommands();            } catch (Throwable tr) {                mCancelled.set(true);                throw tr;            } finally {                postResult(result);            }            return result;        }    };    mFuture = new FutureTask&lt;Result&gt;(mWorker) {        @Override        protected void done() {            try {                postResultIfNotInvoked(get());            } catch (InterruptedException e) {                android.util.Log.w(LOG_TAG, e);            } catch (ExecutionException e) {                throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,                        e.getCause());            } catch (CancellationException e) {                postResultIfNotInvoked(null);            }        }    };}</code></pre><p>可以看到mWorker是WorkerRunnable的实例，而它实现了Callable<result>接口，并在call()方法中调用了doInBackground来处理任务并获取结果，最终通过postResult方法将结果送出：</result></p><pre><code>   private Result postResult(Result result) {    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,            new AsyncTaskResult&lt;Result&gt;(this, result));    message.sendToTarget();    return result;}</code></pre><p>还是那个熟悉的套路，通过Handler进行消息的发送，那么必须会有一个地方来进行消息的处理：</p><pre><code>   private static class InternalHandler extends Handler {    public InternalHandler(Looper looper) {        super(looper);    }    @Override    public void handleMessage(Message msg) {        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;        switch (msg.what) {            case MESSAGE_POST_RESULT:                // There is only one result                result.mTask.finish(result.mData[0]);                break;            case MESSAGE_POST_PROGRESS:                result.mTask.onProgressUpdate(result.mData);                break;        }    }}   private void finish(Result result) {    if (isCancelled()) {        onCancelled(result);    } else {        onPostExecute(result);    }    mStatus = Status.FINISHED;}</code></pre><p>收到消息并在处理完毕后变更任务状态，将任务的处理结果回调出去。<br>而变量mFuture，它是FutureTask的实例，FutureTask是一个可取消的异步任务，它实现了Runnable和Future接口，并且可以包装Callable和Runnable对象然后交由Executor执行。这里WorkerRunnable作为参数被包装进了FutureTask。</p><p>那么我们回过头来看看<code>exec.execute(mFuture)</code>方法：</p><pre><code>private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static class SerialExecutor implements Executor {    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();    Runnable mActive;    public synchronized void execute(final Runnable r) {        mTasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (mActive == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((mActive = mTasks.poll()) != null) {            THREAD_POOL_EXECUTOR.execute(mActive);        }    }}</code></pre><p>这里exec其实就是sDefaultExecutor，它是一个串行的线程池。当我们调用execute方法时，就会将上面提到了FutureTask加入到mTasks中。当任务执行完或者没有任务的时候就会执行scheduleNext方法，从mTasks中取出任务并交由THREAD_POOL_EXECUTOR进行处理。</p><h2 id="关于THREAD-POOL-EXECUTOR："><a href="#关于THREAD-POOL-EXECUTOR：" class="headerlink" title="关于THREAD_POOL_EXECUTOR："></a>关于THREAD_POOL_EXECUTOR：</h2><pre><code>//CPU核数private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();   //线程池核心线程数private static final int CORE_POOL_SIZE = Math.max(2, Math.min(CPU_COUNT - 1, 4));//线程池最大线程数private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE_SECONDS = 30;private static final ThreadFactory sThreadFactory = new ThreadFactory() {    private final AtomicInteger mCount = new AtomicInteger(1);    public Thread newThread(Runnable r) {        return new Thread(r, &quot;AsyncTask #&quot; + mCount.getAndIncrement());    }};private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);public static final Executor THREAD_POOL_EXECUTOR;static {    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(            CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS,            sPoolWorkQueue, sThreadFactory);    threadPoolExecutor.allowCoreThreadTimeOut(true);    THREAD_POOL_EXECUTOR = threadPoolExecutor;}</code></pre><p>可以看到THREAD_POOL_EXECUTOR是一个线程池，也是AsyncTask真正的执行者。<br>如果想要实现并行效果，我们可以通过调用  </p><pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params)， </code></pre><p>定义一个并行执行的Executor即可。<br>至此便是AsyncTask所有的执行流程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说到Android中的异步执行AsyncTask一定不陌生，今天就让我们来到它的内部一探究竟。&lt;/p&gt;
&lt;h2 id=&quot;定义一个异步任务&quot;&gt;&lt;a href=&quot;#定义一个异步任务&quot; class=&quot;headerlink&quot; title=&quot;定义一个异步任务&quot;&gt;&lt;/a&gt;定义一个异步任
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="AsyncTask" scheme="http://9aiplay.com/categories/Android/AsyncTask/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="AsyncTask" scheme="http://9aiplay.com/tags/AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>转载:Android 性能优化</title>
    <link href="http://9aiplay.com/record/f9979545/"/>
    <id>http://9aiplay.com/record/f9979545/</id>
    <published>2018-05-12T03:29:18.000Z</published>
    <updated>2018-07-03T02:12:53.673Z</updated>
    
    <content type="html"><![CDATA[<p>原文作者：鸿洋<br>原文地址：<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650824552&idx=1&sn=a634748d786072ecb083e46f27362d87&chksm=80b78bf6b7c002e09b949b7fbc14b9ae0eb97d8794aca6fa6d42f80afcd27d07947641bab083&scene=21#wechat_redirect" title="原文" target="_blank" rel="noopener">点我跳转原文</a></p><hr><p>一般情况下，我们谈性能优化基本上会从以下几个方面：</p><ul><li>App启动速度优化</li><li>UI流畅度优化</li><li>内存优化</li><li>apk瘦身</li><li>电量优化</li></ul><p>还有些网络速度优化、以及特定类型app的一些针对性的优化，比如播放器起播速度等…</p><p>我们重点谈论上面5个方面。</p><p>性能优化正常的流程是，发现自己某方面与竞品差距比较大，比如UI渲染速度，需要通过某种方式去发现为什么比别人慢，往往需要利用一些工具，然后可以做一些针对性的调优（代码优化、实现方式改变等），当然了在调优的过程中会有一些通用性的调优方式可以帮助你。</p><p>所以本文从共性的角度来看，主要介绍的就是针对以上5个方面的检测工具以及调优方式了。</p><h2 id="App启动速度优化"><a href="#App启动速度优化" class="headerlink" title="App启动速度优化"></a>App启动速度优化</h2><p>对于App启动速度优化，一般情况下我们会利用主题去防止出现白屏；针对启动速度慢，需要尽可能减少Application的onCreate中所要做的事情，比如一些不重要的SDK延迟或者异步加载；多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作；部分将要使用到的类异步加载；还有针对multidex专门做优化的（当然这个随着5.0以上的设备越来越多，影响倒是没有那么大了）。</p><p>下面针对各个方面推荐一些文章：</p><ul><li><p>Android性能优化（一）之启动加速35%<br><a href="http://www.jianshu.com/p/f5514b1a826c" target="_blank" rel="noopener">http://www.jianshu.com/p/f5514b1a826c</a></p></li><li><p>Android冷启动白屏解析，带你一步步分析和解决问题<br><a href="http://blog.csdn.net/guolin_blog/article/details/51019856" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/51019856</a></p></li><li><p>Android APP启动优化<br><a href="http://wuxiaolong.me/2017/03/13/appStart/" target="_blank" rel="noopener">http://wuxiaolong.me/2017/03/13/appStart/</a>  </p></li><li><p>App启动速度优化之耗时检测处理<br><a href="http://www.jianshu.com/p/a0e242d57360" target="_blank" rel="noopener">http://www.jianshu.com/p/a0e242d57360</a></p></li></ul><p>上面几篇文章基本上描述了应用的启动流程，如何优化白屏，以及一些SDK的懒加载等等…</p><ul><li><p>美团Android DEX自动拆包及动态加载简介，<br><a href="https://tech.meituan.com/mt-android-auto-split-dex.html" target="_blank" rel="noopener">https://tech.meituan.com/mt-android-auto-split-dex.html</a></p></li><li><p>Android MultiDex初次启动APP优化，<br><a href="http://blog.csdn.net/synaric/article/details/53540760" target="_blank" rel="noopener">http://blog.csdn.net/synaric/article/details/53540760</a></p></li><li><p>其实你不知道MultiDex到底有多坑，<br><a href="http://t.cn/RjjhD95" target="_blank" rel="noopener">http://t.cn/RjjhD95</a></p></li></ul><p>这3篇可以帮助你对multidex做一定的了解，以及提供了优化方案供参考。</p><p>当然了，在检测启动优化上，除了利用adb命令去检测总时间，还有就是去发现耗时的方法，可以利用TraceView，或者打开StrictMode，如果你喜欢使用Log，还可以去使用hugo，或者自己写一个类似的AOP日志框架。</p><p>关于TraceView的使用可以参考：</p><ul><li><p>TraceView 简介及其案例实战，<br><a href="https://www.cnblogs.com/sunzn/p/3192231.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunzn/p/3192231.html</a></p></li><li><p>使用 TraceView 找到卡顿的元凶，<br><a href="http://blog.csdn.net/u011240877/article/details/54347396" target="_blank" rel="noopener">http://blog.csdn.net/u011240877/article/details/54347396</a></p></li><li><p>Android App优化之提升你的App启动速度之实例挑战，<br><a href="http://www.jianshu.com/p/4f10c9a10ac9" target="_blank" rel="noopener">http://www.jianshu.com/p/4f10c9a10ac9</a></p></li></ul><p>StrictMode比较简单，就不描述了，hugo是Jake大神的一个开源库，主要是利用aspectJ，源码很少，也比较简单，不过使用起来还不错，直接看readme就够了，感兴趣可以看下~<br><a href="https://github.com/JakeWharton/hugo" target="_blank" rel="noopener">https://github.com/JakeWharton/hugo</a></p><h2 id="UI流畅度优化"><a href="#UI流畅度优化" class="headerlink" title="UI流畅度优化"></a>UI流畅度优化</h2><p>谈到UI流畅度，一般就是不要在主进程去做耗时的操作，提升UI的绘制速度（减少View的布局层级，避免过渡绘制等）…TraceView、Lint、Hugo、StrictMode等…</p><p>这里很容易想起Google在15年初google发布了Android性能优化典范，还好视频还被我找到了，文末有下载…</p><p>对于优化方案可参考：</p><ul><li><p>Android性能优化（二）之布局优化面面观<br><a href="http://www.jianshu.com/p/4f44a178c547" target="_blank" rel="noopener">http://www.jianshu.com/p/4f44a178c547</a></p></li><li><p>Android UI性能优化实战 识别绘制中的性能问题<br><a href="http://blog.csdn.net/lmj623565791/article/details/45556391/" target="_blank" rel="noopener">http://blog.csdn.net/lmj623565791/article/details/45556391/</a></p></li><li><p>性能优化之布局优化<br><a href="http://www.trinea.cn/android/layout-performance/" target="_blank" rel="noopener">http://www.trinea.cn/android/layout-performance/</a></p></li><li><p>Android性能调优<br><a href="http://www.trinea.cn/android/android-performance-demo/" target="_blank" rel="noopener">http://www.trinea.cn/android/android-performance-demo/</a></p></li></ul><p>当然了对于UI卡顿，不可避免的要引入检测的方案：</p><p>一般有监听Looper的日志</p><p>利用Choreographer</p><p>可参考我之前编写的：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&mid=2650822205&idx=1&sn=6b8e78bc1d71eb79a199667cf132acf7&chksm=80b782a3b7c00bb5c12437556fca68136c75409855e9252e395b545621319edf23959942b67c&scene=21#wechat_redirect" title="            Android UI性能优化 检测应用中的UI卡" target="_blank" rel="noopener">Android UI性能优化 检测应用中的UI卡</a></p><p>当然也相应的有一些开源工具：</p><p><a href="https://github.com/markzhai/AndroidPerformanceMonitor" target="_blank" rel="noopener">https://github.com/markzhai/AndroidPerformanceMonitor</a> [方式1]</p><p><a href="https://github.com/wasabeef/Takt" target="_blank" rel="noopener">https://github.com/wasabeef/Takt</a> [方式2]</p><p><a href="https://github.com/friendlyrobotnyc/TinyDancer" target="_blank" rel="noopener">https://github.com/friendlyrobotnyc/TinyDancer</a> [方式2]</p><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>内存优化那么主要就是去消除应用中的内存泄露、避免内存抖动；常用工具就是AS自带的内存检测，可以很好的发现内存抖动；leakcanary可以非常方便的帮助我们发现内存泄露；MAT可以做更多的内存分析。</p><p>当然了，你还可以了解一些内存相关的基础知识。</p><ul><li><p>Android性能优化（三）之内存管理<br><a href="http://www.jianshu.com/p/c4b283848970" target="_blank" rel="noopener">http://www.jianshu.com/p/c4b283848970</a></p></li><li><p>Android性能优化第（二）篇—Memory Monitor检测内存泄露<br><a href="http://www.jianshu.com/p/ef9081050f5c" target="_blank" rel="noopener">http://www.jianshu.com/p/ef9081050f5c</a></p></li><li><p>内存泄露实例分析 – Android内存优化第四弹<br><a href="http://www.jianshu.com/p/cbe2ee08ca02" target="_blank" rel="noopener">http://www.jianshu.com/p/cbe2ee08ca02</a></p></li><li><p>Android最佳性能实践(一)——合理管理内存<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238627" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/42238627</a></p></li><li><p>Android最佳性能实践(二)——分析内存的使用情况<br><a href="http://blog.csdn.net/guolin_blog/article/details/42238633" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/42238633</a></p></li><li><p>Android性能优化-内存泄漏的8个Case<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822597&amp;idx=1&amp;sn=462b116f97623f239ecf667d3bdef446&amp;chksm=80b7835bb7c00a4d4cbc9f7e19829d9a99f3cf58c1bc43dace16ffec58c98668927c9fa8dcda&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650822597&amp;idx=1&amp;sn=462b116f97623f239ecf667d3bdef446&amp;chksm=80b7835bb7c00a4d4cbc9f7e19829d9a99f3cf58c1bc43dace16ffec58c98668927c9fa8dcda&amp;scene=21#wechat_redirect</a></p></li><li><p>Android 内存优化总结&amp;实践<br><a href="https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2MsEAR9pQfMr1Sfs7cPdWQ</a></p></li><li><p>Android内存优化之OOM<br><a href="http://hukai.me/android-performance-oom/" target="_blank" rel="noopener">http://hukai.me/android-performance-oom/</a></p></li><li><p>Android应用内存泄露分析、改善经验总结<br><a href="https://zhuanlan.zhihu.com/p/20831913" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20831913</a></p></li><li><p>内存泄露从入门到精通三部曲之基础知识篇<br><a href="http://dev.qq.com/topic/59152c9029d8be2a14b64dae" target="_blank" rel="noopener">http://dev.qq.com/topic/59152c9029d8be2a14b64dae</a></p></li><li><p>内存泄露从入门到精通三部曲之排查方法篇<br><a href="http://dev.qq.com/topic/591522d9142eee2b6b9735a2" target="_blank" rel="noopener">http://dev.qq.com/topic/591522d9142eee2b6b9735a2</a></p></li><li><p>手把手教你在Android Studio 3.0上分析内存泄漏<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824544&amp;idx=1&amp;sn=2fc3cc16806bd1ddd9902ccef2cd12f5&amp;chksm=80b78bfeb7c002e822314661aa0df8e8d7981fb2ff3bc362c129bbf2952a87ff59a6213b821c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824544&amp;idx=1&amp;sn=2fc3cc16806bd1ddd9902ccef2cd12f5&amp;chksm=80b78bfeb7c002e822314661aa0df8e8d7981fb2ff3bc362c129bbf2952a87ff59a6213b821c&amp;scene=21#wechat_redirect</a></p></li></ul><h2 id="apk瘦身"><a href="#apk瘦身" class="headerlink" title="apk瘦身"></a>apk瘦身</h2><p>关于Apk瘦身，主要由以下几个方式：</p><p>利用ProGuard压缩代码去除无用资源</p><p>andresguard进一步压缩与混淆资源</p><p>第三方开源库的瘦身，仅保留自己需要的部分</p><p>极致的图片压缩与webp的使用</p><p>合理配置去除不必要的配置，仅保留中文配置等…</p><p>so的优化与配置，只保留一类so</p><p>动态下发一些资源:字库、so、换肤包等；</p><p>以上仅有7比较麻烦，需要服务端的配合，此外对于动态下发So，可以参考tinker对So热修复部分代码。</p><p>其余都是常规方式，且1 ，5，6都比较简单，build.gradle最下配置即可，当然了也有一些参考文章：</p><pre><code>App瘦身最佳实践http://www.jianshu.com/p/8f14679809b3#Android APP终极瘦身指南http://t.cn/RGjNpamAndroid性能优化（十）之App瘦身攻略http://www.jianshu.com/p/99f3c09982d4[Android技术专题]APK瘦身看这一篇文章就够了http://www.jianshu.com/p/6be4f98162d7安装包立减1M--微信Android资源混淆打包工具http://t.cn/RjjVe4f爱奇艺Android移动客户端app瘦身经验http://t.cn/RjjfzrYAndroid Webp 完全解析 快来缩小apk的大小吧App优化攻略-用TextView显示图片Android IconFont全攻略</code></pre><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><p>电量优化说实在的关注度较低，一般情况就是合理的使用一些传感器、谨慎的使用Wake Lock、减少后台的不要的操作等…检测可以利用battery-historian </p><pre><code>Android性能优化（九）之不可忽视的电量http://www.jianshu.com/p/5d83d8649c98Android性能优化之电量篇http://hukai.me/android-performance-battery/Android性能优化-电量优化Android性能优化系列之电量优化http://blog.csdn.net/u012124438/article/details/74617649Android App优化之电池省着用http://www.jianshu.com/p/c55ef05c0047https://github.com/google/battery-historian</code></pre><p>好了，大家可以将每个方案的所采用的实际的优化策略记录下来，对每种方式提到的工具一定要自己去体验，用起来肯定不会有多么的困难，实操起来印象会更加深刻。</p><p>性能优化并不困难，重要的还是要去实际的去操作一把，基本上也是面试常见的问题了。</p><p>最后，好文非常多，本文希望仅起到抛砖引入的效果，感谢所有作者~</p><p>想起来了16年MDCC上明云凶做过一个性能优化的分享，所以每次谈到性能优化我都能想到当年演讲的ppt。</p><p>这里提供一下该ppt的下载以及Google的性能优化典范视频，链接：<a href="https://pan.baidu.com/s/1kVHyCUb，懒得复制的可以公众号内回复1118即可。" target="_blank" rel="noopener">https://pan.baidu.com/s/1kVHyCUb，懒得复制的可以公众号内回复1118即可。</a></p><p>对了，腾讯有个非常强大的手机上的“集成调测环境”，就是手机上的软件，可以用于性能检测，叫GT。<br><a href="http://gt.tencent.com/download.html" target="_blank" rel="noopener">http://gt.tencent.com/download.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文作者：鸿洋&lt;br&gt;原文地址：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650824552&amp;idx=1&amp;sn=a634748d786072ecb083e46f27362d87&amp;chksm
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="性能优化" scheme="http://9aiplay.com/categories/Android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="性能优化" scheme="http://9aiplay.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Android-ADB常用命令</title>
    <link href="http://9aiplay.com/record/da31a3cc/"/>
    <id>http://9aiplay.com/record/da31a3cc/</id>
    <published>2018-05-08T06:30:05.000Z</published>
    <updated>2018-07-03T02:12:53.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h2><ul><li>进入指定设备 <code>adb -s serialNumber shell</code></li><li>查看版本   <code>adb version</code></li><li>查看日志  <code>adb logcat</code></li><li>查看设备  <code>adb devices</code></li><li>连接状态  <code>adb get-state</code></li><li>动启ADB服务 <code>adb start-server</code></li><li>停止ADB服务  <code>adb kill-server</code></li><li>电脑推送到手机 <code>adb push local remote</code></li><li>手机拉取到电脑 <code>adb pull remote local</code></li></ul><h2 id="adb-shell下的am-与-pm"><a href="#adb-shell下的am-与-pm" class="headerlink" title="adb shell下的am 与 pm"></a>adb shell下的am 与 pm</h2><blockquote><p>am和pm命令必须先切换到adb shell模式下才能使用</p></blockquote><h3 id="am"><a href="#am" class="headerlink" title="am"></a>am</h3><p>am全称activity manager，你能使用am去模拟各种系统的行为，例如去启动一个activity，强制停止进程，发送广播进程，修改设备屏幕属性等等。当你在adb shell命令下执行am命令</p><pre><code>am &lt;comman&gt;</code></pre><ul><li>启动app am start -n {packageName}/.{activityName}</li><li>杀app的进程 am kill <packagename></packagename></li><li>强制停止一切 am force-stop <packagename></packagename></li><li>启动服务am startservice</li><li>停止服务 am stopservice</li><li>打开简书 am start -a android.intent.action.VIEW -d <a href="http://www.jianshu.com/" target="_blank" rel="noopener">http://www.jianshu.com/</a></li><li>拨打10086 am start -a android.intent.action.CALL -d tel:10086</li></ul><h3 id="pm"><a href="#pm" class="headerlink" title="pm"></a>pm</h3><p>pm全称package manager，你能使用pm命令去模拟Android行为或者查询设备上的应用等，当你在adb shell命令下执行pm命令</p><pre><code>pm &lt;command&gt;</code></pre><ul><li>列出手机所有的包名 pm list packages</li><li>安装/卸载 pm install/uninstall</li></ul><h2 id="模拟用户事件"><a href="#模拟用户事件" class="headerlink" title="模拟用户事件"></a>模拟用户事件</h2><ul><li>文本输入:<code>adb shell input text &lt;string&gt;</code><ul><li>例:手机端输出demo字符串，相应指令：<code>adb shell input &quot;demo&quot;.</code></li></ul></li><li>键盘事件：<code>input keyevent &lt;KEYCODE&gt;，其中KEYCODE见本文结尾的附表</code><ul><li>例:点击返回键，相应指令： <code>input keyevent 4.</code></li></ul></li><li>点击事件：<code>input tap &lt;x&gt; &lt;y&gt;</code><ul><li>例: 点击坐标（500，500），相应指令：<code>input tap 500 500.</code></li></ul></li><li>滑动事件：<code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; &lt;time&gt;</code><ul><li>例:从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500.</code></li><li>例:200ms时间从坐标(300，500)滑动到(100，500)，相应指令： <code>input swipe 300 500 100 500 200.</code></li></ul></li></ul><h3 id="循环-shell命令"><a href="#循环-shell命令" class="headerlink" title="循环 shell命令:"></a>循环 shell命令:</h3><p>连接adb后输入 adb shell input tap X坐标 Y坐标</p><blockquote><p>左边 adb shell input tap 279 1897<br>右边 adb shell input tap 1085 1880</p></blockquote><pre><code>@echo offset var=0rem ************循环开始了:continueset /a var+=1echo 第%var%次循环adb shell input tap 279 1897adb shell input tap 1085 1880if %var% lss 0 goto continuerem ************循环结束了echo 循环执行完毕pause</code></pre><h3 id="执行shell以后的命令"><a href="#执行shell以后的命令" class="headerlink" title="执行shell以后的命令"></a>执行shell以后的命令</h3><pre><code>adb shell &lt;123.txt</code></pre><h2 id="logcat日志"><a href="#logcat日志" class="headerlink" title="logcat日志"></a>logcat日志</h2><ul><li>显示包含的<code>logcat logcat \| grep &lt;str&gt;</code></li><li>显示包含，并忽略大小写的<code>logcat logcat \| grep -i &lt;str&gt;</code></li><li>读完所有log后返回，而不会一直等待 <code>logcat -d</code></li><li>清空log并退出 <code>logcat -c</code></li><li>打印最近的<code>count logcat -t &lt;count&gt;</code></li><li>格式化输出Log，其中format有如下可选值：<code>logcat -v &lt;format&gt;</code></li></ul><blockquote><p>brief — 显示优先级/标记和原始进程的PID (默认格式)<br>process — 仅显示进程PID<br>tag — 仅显示优先级/标记<br>thread — 仅显示进程：线程和优先级/标记<br>raw — 显示原始的日志信息，没有其他的元数据字段<br>time — 显示日期，调用时间，优先级/标记，PID<br>long —显示所有的元数据字段并且用空行分隔消息内容  </p></blockquote><h2 id="常用节点"><a href="#常用节点" class="headerlink" title="常用节点"></a>常用节点</h2><blockquote><p>查看节点值，例如：<code>cat /sys/class/leds/lcd-backlight/brightness</code><br>修改节点值，例如：<code>echo 128 &gt; sys/class/leds/lcd-backlight/brightness</code></p></blockquote><ul><li>LPM: <code>echo N &gt; /sys/modue/lpm_levels/parameters/sleep_disabled</code></li><li>亮度：<code>/sys/class/leds/lcd-backlight/brightness</code></li><li>CPU: <code>/sys/devices/system/cpu/cpu0/cpufreq</code></li><li>GPU: <code>/sys/class/ kgsl/kgsl-3d0/gpuclk</code></li><li>限频：<code>cat /data/pmlist.config</code></li><li>电流：<code>cat /sys/class/power_supply/battery/current_now</code></li><li>查看Power： <code>dumpsys power</code></li><li>WIFI :<code>data/misc/wifi/wpa_supplicant.conf</code></li><li>持有wake_lock:<code>echo a&gt; sys/power/wake_lock</code></li><li>释放wake_lock:<code>echo a&gt; sys/power/wake_unlock</code></li><li>查看Wakeup_source: <code>cat sys/kernel/debug/wakeup_sources</code></li><li>Display(关闭AD):<code>mv /data/misc/display/calib.cfg /data/misc/display/calib.cfg.bak 重启</code></li><li>关闭cabc：<code>echo 0 &gt; /sys/device/virtual/graphics/fb0/cabc_onoff</code></li><li>打开cabc：<code>echo 3 &gt; /sys/device/virtual/graphics/fb0/cabc_onoff</code></li><li>systrace：<code>sdk/tools/monitor</code></li><li>限频：<code>echo /sys/devices/system/cpu/cpu0/cpufreq/scaling_max_freq 1497600</code></li><li>当出现read-only 且 remount命令不管用时：<code>adb shell mount -o rw,remount /</code></li><li>进入9008模式： <code>adb reboot edl</code></li><li>查看高通gpio：<code>sys/class/private/tlmm</code>或者 <code>sys/private/tlmm</code></li><li>查看gpio占用情况：<code>sys/kernle/debug/gpio</code></li></ul><h2 id="远程ADB"><a href="#远程ADB" class="headerlink" title="远程ADB"></a>远程ADB</h2><p>为避免使用数据线，可通过wifi通信，前提是手机与PC处于同一局域网</p><h3 id="启动方法"><a href="#启动方法" class="headerlink" title="启动方法"></a>启动方法</h3><pre><code>adb tcpip 5555  //这一步，必须通过数据线把手机与PC连接后再执行  adb connect &lt;手机IP&gt;</code></pre><h3 id="停止方法"><a href="#停止方法" class="headerlink" title="停止方法"></a>停止方法</h3><pre><code>adb disconnect //断开wifi连接adb usb //切换到usb模式</code></pre><h2 id="常用操作示例"><a href="#常用操作示例" class="headerlink" title="常用操作示例"></a>常用操作示例</h2><ul><li>查看当前 <code>ls</code></li><li>打印当前路径 <code>pwd</code></li><li>查看当前连接的设备 <code>adb devices</code></li><li>终止adb服务进程 <code>adb kill-server</code></li><li>重启adb服务进程 <code>adb start-server</code></li><li>PID是:8607 查看某个进程的日志 <code>adb logcat -v process |grep 8607</code></li><li>清理缓存 <code>logcat -c</code></li><li>打印xys标签log <code>adb logcat -s xys</code></li><li>打印192.168.56.101:5555设备里的xys标签log <code>adb -s 192.168.56.101:5555 logcat -s xys</code></li><li>打印在ActivityManager标签里包含start的日志 <code>adb logcat -s ActivityManager | findstr &quot;START&quot;</code></li></ul><blockquote><p>“-s”选项 : 设置输出日志的标签, 只显示该标签的日志;<br>“-f”选项 : 将日志输出到文件, 默认输出到标准输出流中, -f 参数执行不成功;<br>“-r”选项 : 按照每千字节输出日志, 需要 -f 参数, 不过这个命令没有执行成功;<br>“-n”选项 : 设置日志输出的最大数目, 需要 -r 参数, 这个执行 感觉 跟 adb logcat 效果一样;<br>“-v”选项 : 设置日志的输出格式, 注意只能设置一项;<br>“-c”选项 : 清空所有的日志缓存信息;<br>“-d”选项 : 将缓存的日志输出到屏幕上, 并且不会阻塞;<br>“-t”选项 : 输出最近的几行日志, 输出完退出, 不阻塞;<br>“-g”选项 : 查看日志缓冲区信息;<br>“-b”选项 : 加载一个日志缓冲区, 默认是 main, 下面详解;<br>“-B”选项 : 以二进制形式输出日志;  </p></blockquote><ul><li>重启机器 <code>adb reboot</code></li><li>获取序列号 <code>adb get-serialno</code></li><li>重启到bootloader，即刷机模式 <code>adb reboot bootloader</code></li><li>重启到recovery，即恢复模式 <code>adb reboot recovery</code></li><li>安装APK：adb install <apkfile> //比如：<code>adb install baidu.apk</code></apkfile></li><li>安装apk到sd卡： adb install -s <apkfile> // 比如：<code>adb install -s baidu.apk</code></apkfile></li><li>卸载APK：adb uninstall <package> //比如：<code>adb uninstall com.baidu.search</code></package></li><li>获取机器MAC地址 <code>adb shell cat /sys/class/net/wlan0/address</code></li><li>启动应用：adb shell am start -n <package_name>/.<activity_class_name> <ul><li>例如:<code>adb shell am start -n yf.o2o.store/yf.o2o.store.activity.LoginActivity</code></li></ul></activity_class_name></package_name></li><li>查看占用内存排序  <code>adb shell top</code></li><li>查看占用内存前6的app：<code>adb shell top -m 6</code></li><li>刷新一次内存信息，然后返回：<code>adb shell top -n 1</code></li><li>查询各进程内存使用情况：<code>adb shell procrank</code></li><li>杀死一个进程：<code>adb shell kill [pid]</code></li><li>查看进程列表：<code>adb shell ps</code></li><li>查看指定进程状态：<code>adb shell ps -x [PID]</code></li><li>查看后台services信息： <code>adb shell service list</code></li><li>查看当前内存占用： <code>adb shell cat /proc/meminfo</code></li><li>查看IO内存分区：<code>adb shell cat /proc/iomem</code></li><li>将system分区重新挂载为可读写分区：<code>adb remount</code></li><li>从本地复制文件到设备： <code>adb push &lt;local&gt; &lt;remote&gt;</code></li><li>从设备复制文件到本地： <code>adb pull &lt;remote&gt; &lt;local&gt;</code></li><li>列出目录下的文件和文件夹，等同于dos中的dir命令：<code>adb shell ls</code></li><li>进入文件夹，等同于dos中的cd 命令：<code>adb shell cd &lt;folder&gt;</code></li><li>重命名文件： <code>adb shell rename path/oldfilename path/newfilename</code></li><li>删除system/avi.apk： <code>adb shell rm /system/avi.apk</code></li><li>删除文件夹及其下面所有文件：<code>adb shell rm -r &lt;folder&gt;</code></li><li>移动文件：<code>adb shell mv path/file newpath/file</code></li><li>设置文件权限：<code>adb shell chmod 777 /system/fonts/DroidSansFallback.ttf</code></li><li>新建文件夹：<code>adb shell mkdir path/foldelname</code></li><li>查看文件内容：<code>adb shell cat &lt;file&gt;</code></li><li>查看wifi密码：<code>adb shell cat /data/misc/wifi/*.conf</code></li><li>清除log缓存：<code>adb logcat -c</code></li><li>查看bug报告：<code>adb bugreport</code></li><li>获取设备名称：<code>adb shell cat /system/build.prop</code></li><li>查看ADB帮助：<code>adb help</code></li><li>跑monkey：<code>adb shell monkey -v -p your.package.name 500</code> <code>adb -s 192.168.244.151:5555 shell monkey -v -p com.bolexim 500</code></li></ul><h2 id="附表"><a href="#附表" class="headerlink" title="附表"></a>附表</h2><p>下表中， 箭头左边为keycode值，箭头右边为keycode的含义，部分用中文标注</p><pre><code>0 –&gt; “KEYCODE_UNKNOWN”1 –&gt; “KEYCODE_MENU”2 –&gt; “KEYCODE_SOFT_RIGHT”3 –&gt; “KEYCODE_HOME” //Home键4 –&gt; “KEYCODE_BACK” //返回键5 –&gt; “KEYCODE_CALL” 6 –&gt; “KEYCODE_ENDCALL” 7 –&gt; “KEYCODE_0” //数字键08 –&gt; “KEYCODE_1” 9 –&gt; “KEYCODE_2” 10 –&gt; “KEYCODE_3”11 –&gt; “KEYCODE_4” 12 –&gt; “KEYCODE_5” 13 –&gt; “KEYCODE_6” 14 –&gt; “KEYCODE_7” 15 –&gt; “KEYCODE_8” 16 –&gt; “KEYCODE_9” 17 –&gt; “KEYCODE_STAR” 18 –&gt; “KEYCODE_POUND” 19 –&gt; “KEYCODE_DPAD_UP” 20 –&gt; “KEYCODE_DPAD_DOWN” 21 –&gt; “KEYCODE_DPAD_LEFT”22 –&gt; “KEYCODE_DPAD_RIGHT” 23 –&gt; “KEYCODE_DPAD_CENTER” 24 –&gt; “KEYCODE_VOLUME_UP” //音量键+25 –&gt; “KEYCODE_VOLUME_DOWN” //音量键-26 –&gt; “KEYCODE_POWER” //Power键27 –&gt; “KEYCODE_CAMERA” 28 –&gt; “KEYCODE_CLEAR”29 –&gt; “KEYCODE_A” //字母键A30 –&gt; “KEYCODE_B” 31 –&gt; “KEYCODE_C” 32 –&gt; “KEYCODE_D” 33 –&gt; “KEYCODE_E” 34 –&gt; “KEYCODE_F” 35 –&gt; “KEYCODE_G”36 –&gt; “KEYCODE_H”37 –&gt; “KEYCODE_I”38 –&gt; “KEYCODE_J” 39 –&gt; “KEYCODE_K” 40 –&gt; “KEYCODE_L” 41 –&gt; “KEYCODE_M”42 –&gt; “KEYCODE_N” 43 –&gt; “KEYCODE_O” 44 –&gt; “KEYCODE_P” 45 –&gt; “KEYCODE_Q” 46 –&gt; “KEYCODE_R”47 –&gt; “KEYCODE_S”48 –&gt; “KEYCODE_T” 49 –&gt; “KEYCODE_U” 50 –&gt; “KEYCODE_V” 51 –&gt; “KEYCODE_W” 52 –&gt; “KEYCODE_X”53 –&gt; “KEYCODE_Y” 54 –&gt; “KEYCODE_Z”55 –&gt; “KEYCODE_COMMA” 56 –&gt; “KEYCODE_PERIOD”57 –&gt; “KEYCODE_ALT_LEFT” 58 –&gt; “KEYCODE_ALT_RIGHT” 59 –&gt; “KEYCODE_SHIFT_LEFT” 60 –&gt; “KEYCODE_SHIFT_RIGHT”61 -&gt; “KEYCODE_TAB” 62 –&gt; “KEYCODE_SPACE” 63 –&gt; “KEYCODE_SYM” 64 –&gt; “KEYCODE_EXPLORER” 65 –&gt; “KEYCODE_ENVELOPE” 66 –&gt; “KEYCODE_ENTER” //回车键67 –&gt; “KEYCODE_DEL” 68 –&gt; “KEYCODE_GRAVE” 69 –&gt; “KEYCODE_MINUS” 70 –&gt; “KEYCODE_EQUALS” 71 –&gt; “KEYCODE_LEFT_BRACKET” 72 –&gt; “KEYCODE_RIGHT_BRACKET” 73 –&gt; “KEYCODE_BACKSLASH” 74 –&gt; “KEYCODE_SEMICOLON” 75 –&gt; “KEYCODE_APOSTROPHE”76 –&gt; “KEYCODE_SLASH” 77 –&gt; “KEYCODE_AT” 78 –&gt; “KEYCODE_NUM” 79 –&gt; “KEYCODE_HEADSETHOOK” 80 –&gt; “KEYCODE_FOCUS”81 –&gt; “KEYCODE_PLUS”82 –&gt; “KEYCODE_MENU”83 –&gt; “KEYCODE_NOTIFICATION”84 –&gt; “KEYCODE_SEARCH”</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本指令&quot;&gt;&lt;a href=&quot;#基本指令&quot; class=&quot;headerlink&quot; title=&quot;基本指令&quot;&gt;&lt;/a&gt;基本指令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;进入指定设备 &lt;code&gt;adb -s serialNumber shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="Adb" scheme="http://9aiplay.com/categories/Android/Adb/"/>
    
      <category term="Utils" scheme="http://9aiplay.com/categories/Android/Adb/Utils/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="Adb" scheme="http://9aiplay.com/tags/Adb/"/>
    
      <category term="Utils" scheme="http://9aiplay.com/tags/Utils/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler的使用</title>
    <link href="http://9aiplay.com/record/141ab2e4/"/>
    <id>http://9aiplay.com/record/141ab2e4/</id>
    <published>2018-05-05T04:28:44.000Z</published>
    <updated>2019-02-27T01:15:58.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Handler概述"><a href="#Handler概述" class="headerlink" title="Handler概述"></a>Handler概述</h2><p>我们都悉知在Android中，如果某项任务的执行时间太长就会导致程序ANR(Application Not Response)，所以我们都会通过将耗时操作转移到子线程执行，从而避免ANR的出现。但是Android规定UI的更新只能在主线程中进行，一旦在子线程中访问UI就会抛出异常。而Handler正是Android为了解决这一矛盾提供的解决方式。<br>首先明确几个需要着重理解的概念：</p><ul><li>Message：消息，携带了描述信息和数据，是Handler进行处理的对象</li><li>MessageQueue：消息队列，用来存放所有通过Handler发布的消息，因为是队列，所以是先进先出的。</li><li>Looper：不断循环从MessageQueue中取出Message，并交给相应的Handler进行处理。</li><li>Handler：负责将Message添加到消息队列以及从Looper抽取出来的Message进行处理。</li></ul><h2 id="创建Handler实例"><a href="#创建Handler实例" class="headerlink" title="创建Handler实例"></a>创建Handler实例</h2><p>首先先进行Handler的实例创建</p><pre><code>new Handler();    Log.d(&quot;main&quot;, &quot;handler1&quot;);new Thread(new Runnable() {    @Override    public void run() {      new Handler();      Log.d(&quot;thread&quot;, &quot;handler2&quot;);    }}).start();</code></pre><p>我们可以发现，当执行到新线程中创建Handler时会抛出异常：</p><pre><code>java.lang.RuntimeException: Can&apos;t create handler inside thread that has not called Looper.prepare()</code></pre><p>而如果我们在代码中把<code>Looper.prepare()</code>加上，就可以正常运行：</p><pre><code>new Thread(new Runnable() {@Overridepublic void run() {  Looper.prepare();  new Handler();  Log.d(&quot;thread&quot;, &quot;handler2&quot;);}}).start();</code></pre><p>我们回过头来看看Handler实例的时候都做了些什么：</p><pre><code>public Handler() {    if (FIND_POTENTIAL_LEAKS) {        final Class&lt;? extends Handler&gt; klass = getClass();        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {            Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +                klass.getCanonicalName());        }    }    mLooper = Looper.myLooper();    if (mLooper == null) {        throw new RuntimeException(            &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);    }    mQueue = mLooper.mQueue;    mCallback = callback;}</code></pre><p>可以看到，当<code>mLooper == null</code>时就会抛出刚所说的异常。那么Looper对象何时为空呢？</p><pre><code>public static final Looper myLooper() {      return (Looper)sThreadLocal.get();  }</code></pre><p>可以看到Looper对象是从sThreadLocal中取出。而通过Looper.prepare()就可以设置这个对象：</p><pre><code>private static void prepare(boolean quitAllowed) {    if (sThreadLocal.get() != null) {        throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);    }    sThreadLocal.set(new Looper(quitAllowed));}</code></pre><p>那么为什么在主线程中创建Handler的时候没有报错呢？答案就在ActivityThread中的main()方法</p><pre><code>public static void main(String[] args) {    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);    SamplingProfilerIntegration.start();    // CloseGuard defaults to true and can be quite spammy.  We    // disable it here, but selectively enable it later (via    // StrictMode) on debug builds, but using DropBox, not logs.    CloseGuard.setEnabled(false);    Environment.initForCurrentUser();    // Set the reporter for event logging in libcore    EventLogger.setReporter(new EventLoggingReporter());    // Make sure TrustedCertificateStore looks in the right place for CA certificates    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());    TrustedCertificateStore.setDefaultUserDirectory(configDir);    Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);    //关键点    Looper.prepareMainLooper();    ActivityThread thread = new ActivityThread();    thread.attach(false);    if (sMainThreadHandler == null) {        sMainThreadHandler = thread.getHandler();    }    if (false) {        Looper.myLooper().setMessageLogging(new                LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));    }    // End of event ActivityThreadMain.    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}public static void prepareMainLooper() {    prepare(false);    synchronized (Looper.class) {        if (sMainLooper != null) {            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);        }        sMainLooper = myLooper();    }}</code></pre><p>可以看到在Activity生命周期开始的后就通过调用Looper.prepareMainLooper()创建了一个主线程的Looper。</p><p>所以主线程可以直接创建Handler对象，而子线程则需要先调用Looper.prepare()</p><h2 id="Handler消息发送"><a href="#Handler消息发送" class="headerlink" title="Handler消息发送"></a>Handler消息发送</h2><p>先写一个简单的消息发送示例：</p><pre><code>Handler handler = new Handler();Message msg = new Message();msg.arg1 = 1;Bundle bundle = new Bundle();bundle.putString(&quot;data&quot;, &quot;test&quot;);msg.setData(bundle);handler.sendMessage(msg);</code></pre><p>Handler提供了几个发送的方法，其中经过辗转后面都会调用该方法<code>sendMessageAtTime(Message msg, long uptimeMillis)：</code></p><pre><code>public boolean sendMessageAtTime(Message msg, long uptimeMillis) {    MessageQueue queue = mQueue;    if (queue == null) {        RuntimeException e = new RuntimeException(                this + &quot; sendMessageAtTime() called with no mQueue&quot;);        Log.w(&quot;Looper&quot;, e.getMessage(), e);        return false;    }    return enqueueMessage(queue, msg, uptimeMillis);}</code></pre><p>通过enqueueMessage()方法进行消息入队。</p><pre><code>MessageQueue.enqueueMessage(Message msg, long when)：boolean enqueueMessage(Message msg, long when) {    if (msg.target == null) {        throw new IllegalArgumentException(&quot;Message must have a target.&quot;);    }    if (msg.isInUse()) {        throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);    }    synchronized (this) {        if (mQuitting) {            IllegalStateException e = new IllegalStateException(                    msg.target + &quot; sending message to a Handler on a dead thread&quot;);            Log.w(TAG, e.getMessage(), e);            msg.recycle();            return false;        }        msg.markInUse();        msg.when = when;        Message p = mMessages;        boolean needWake;        if (p == null || when == 0 || when &lt; p.when) {            // New head, wake up the event queue if blocked.            msg.next = p;            mMessages = msg;            needWake = mBlocked;        } else {            // Inserted within the middle of the queue.  Usually we don&apos;t have to wake            // up the event queue unless there is a barrier at the head of the queue            // and the message is the earliest asynchronous message in the queue.            needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();            Message prev;            for (;;) {                prev = p;                p = p.next;                if (p == null || when &lt; p.when) {                    break;                }                if (needWake &amp;&amp; p.isAsynchronous()) {                    needWake = false;                }            }            msg.next = p; // invariant: p == prev.next            prev.next = msg;        }        // We can assume mPtr != 0 because mQuitting is false.        if (needWake) {            nativeWake(mPtr);        }    }    return true;}</code></pre><p>因为存在多线程插入消息，所以需要加上同步；参数<code>when=SystemClock.uptimeMillis()+delayMillis</code>，如果调用的是post方法则delayMillis为0；mMessages代表的是消息队列的头部，当它为空的时候表示队列没有消息，并且根据当前的Loop线程的状态来判断是否需要唤醒队列；否则插入消息并且根据when来对msg进行队列的排序；最后判断是否需要唤醒Looper线程，至此完成了消息的加入。</p><h2 id="Handler消息处理"><a href="#Handler消息处理" class="headerlink" title="Handler消息处理"></a>Handler消息处理</h2><p>在上面提到的ActivityThread.main()方法中，不仅调用了Looper.prepareMainLooper,而且也调用了Looper.loop方法</p><p>public static void loop() {<br>        final Looper me = myLooper();<br>        if (me == null) {<br>            throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);<br>        }<br>        final MessageQueue queue = me.mQueue;</p><pre><code>    // Make sure the identity of this thread is that of the local process,    // and keep track of what that identity token actually is.    Binder.clearCallingIdentity();    final long ident = Binder.clearCallingIdentity();    for (;;) {        Message msg = queue.next(); // might block        if (msg == null) {            // No message indicates that the message queue is quitting.            return;        }        // This must be in a local variable, in case a UI event sets the logger        final Printer logging = me.mLogging;        if (logging != null) {            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                    msg.callback + &quot;: &quot; + msg.what);        }        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;        final long traceTag = me.mTraceTag;        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));        }        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();        final long end;        try {            msg.target.dispatchMessage(msg);            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();        } finally {            if (traceTag != 0) {                Trace.traceEnd(traceTag);            }        }        if (slowDispatchThresholdMs &gt; 0) {            final long time = end - start;            if (time &gt; slowDispatchThresholdMs) {                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;                        + Thread.currentThread().getName() + &quot;, h=&quot; +                        msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);            }        }        if (logging != null) {            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);        }        // Make sure that during the course of dispatching the        // identity of the thread wasn&apos;t corrupted.        final long newIdent = Binder.clearCallingIdentity();        if (ident != newIdent) {            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;                    + Long.toHexString(ident) + &quot; to 0x&quot;                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;                    + msg.target.getClass().getName() + &quot; &quot;                    + msg.callback + &quot; what=&quot; + msg.what);        }        msg.recycleUnchecked();    }}</code></pre><p>首先获取到当前Looper和MessageQueue实例，然后通过一个死循环经queue.next()方法获取下一个Message，当MessageQueue为空，则阻塞队列。而每当有一个消息出队的时候，都会经过msg.target.dispatchMessage(msg)，通过上面我们知道msg.target其实就是Handler。<br>那么我们就来到Handler.dispatchMessage()：</p><pre><code>public void dispatchMessage(Message msg) {    if (msg.callback != null) {        handleCallback(msg);    } else {        if (mCallback != null) {            if (mCallback.handleMessage(msg)) {                return;            }        }        handleMessage(msg);    }}</code></pre><p>如果mCallback不为空，则执行mCallback.handleMessage(msg)；否则走Handler.handleCallback(msg)方法。所以我们可以通过handleMessage()方法获取到之前发送的消息！</p><h2 id="Handler注意事项"><a href="#Handler注意事项" class="headerlink" title="Handler注意事项"></a>Handler注意事项</h2><pre><code>Handler mHandler = new Handler(){    @Override    public void handleMessage(Message msg) {      super.handleMessage(msg);    }  };</code></pre><p>由于java中非静态内部类和匿名内部类都会隐式持有当前类的外部引用，而上图所示的使用方式正是因为Handler是非静态内部类所以其持有当前Activity的隐式引用，如果Handler没有被释放，其所持有的外部引用也就是Activity也无法被释放，本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p><p>而面对这种情况，我们通常的解决方式就是使用静态内部类并继承Handler（或者也可以单独存放成一个类文件）。因为静态的内部类不会持有外部类的引用，所以不会导致外部类实例的内存泄露。当你需要在静态内部类中调用外部的Activity时，我们可以使用弱引用来处理。如下所示：</p><pre><code>private static class MyHandler extends Handler {    //持有弱引用HandlerActivity,GC回收时会被回收掉.      private final WeakReference&lt;MainActivity&gt; mActivty;    public MyHandler(MainActivity activity) {      mActivty = new WeakReference&lt;&gt;(activity);    }    @Override    public void handleMessage(Message msg) {      MainActivity activity = mActivty.get();      super.handleMessage(msg);      if (activity != null) {        //执行业务逻辑        }        }}</code></pre><p>至此完成对Handler分析。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Handler概述&quot;&gt;&lt;a href=&quot;#Handler概述&quot; class=&quot;headerlink&quot; title=&quot;Handler概述&quot;&gt;&lt;/a&gt;Handler概述&lt;/h2&gt;&lt;p&gt;我们都悉知在Android中，如果某项任务的执行时间太长就会导致程序ANR(Appl
      
    
    </summary>
    
    
      <category term="Android" scheme="http://9aiplay.com/categories/Android/"/>
    
      <category term="Handler" scheme="http://9aiplay.com/categories/Android/Handler/"/>
    
    
      <category term="Android" scheme="http://9aiplay.com/tags/Android/"/>
    
      <category term="Handler" scheme="http://9aiplay.com/tags/Handler/"/>
    
  </entry>
  
</feed>
